{"version":3,"sources":["../../node_modules/commander/lib/error.js","../../node_modules/commander/lib/argument.js","../../node_modules/commander/lib/help.js","../../node_modules/commander/lib/option.js","../../node_modules/commander/lib/suggestSimilar.js","../../node_modules/commander/lib/command.js","../../node_modules/commander/index.js","../../src/index.ts","../../src/cli.ts","../../node_modules/commander/esm.mjs","../../src/command.ts","../../src/primary.ts","../../src/worker.ts","../../src/queue.ts"],"sourcesContent":["// @ts-check\n\n/**\n * CommanderError class\n * @class\n */\nclass CommanderError extends Error {\n  /**\n   * Constructs the CommanderError class\n   * @param {number} exitCode suggested exit code which could be used with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @constructor\n   */\n  constructor(exitCode, code, message) {\n    super(message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.exitCode = exitCode;\n    this.nestedError = undefined;\n  }\n}\n\n/**\n * InvalidArgumentError class\n * @class\n */\nclass InvalidArgumentError extends CommanderError {\n  /**\n   * Constructs the InvalidArgumentError class\n   * @param {string} [message] explanation of why argument is invalid\n   * @constructor\n   */\n  constructor(message) {\n    super(1, 'commander.invalidArgument', message);\n    // properly capture stack trace in Node.js\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n  }\n}\n\nexports.CommanderError = CommanderError;\nexports.InvalidArgumentError = InvalidArgumentError;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Argument {\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   */\n\n  constructor(name, description) {\n    this.description = description || '';\n    this.variadic = false;\n    this.parseArg = undefined;\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.argChoices = undefined;\n\n    switch (name[0]) {\n      case '<': // e.g. <required>\n        this.required = true;\n        this._name = name.slice(1, -1);\n        break;\n      case '[': // e.g. [optional]\n        this.required = false;\n        this._name = name.slice(1, -1);\n        break;\n      default:\n        this.required = true;\n        this._name = name;\n        break;\n    }\n\n    if (this._name.length > 3 && this._name.slice(-3) === '...') {\n      this.variadic = true;\n      this._name = this._name.slice(0, -3);\n    }\n  }\n\n  /**\n   * Return argument name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    return this._name;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Argument}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   *\n   * @param {Function} [fn]\n   * @return {Argument}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Only allow argument value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Argument}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Make argument required.\n   */\n  argRequired() {\n    this.required = true;\n    return this;\n  }\n\n  /**\n   * Make argument optional.\n   */\n  argOptional() {\n    this.required = false;\n    return this;\n  }\n}\n\n/**\n * Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @api private\n */\n\nfunction humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required\n    ? '<' + nameOutput + '>'\n    : '[' + nameOutput + ']';\n}\n\nexports.Argument = Argument;\nexports.humanReadableArgName = humanReadableArgName;\n","const { humanReadableArgName } = require('./argument.js');\n\n/**\n * TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option\n */\n\n// @ts-check\n\n// Although this is a class, methods are static in style to allow override using subclass or just functions.\nclass Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n  }\n\n  /**\n   * Get an array of the visible subcommands. Includes a placeholder for the implicit help command, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Command[]}\n   */\n\n  visibleCommands(cmd) {\n    const visibleCommands = cmd.commands.filter(cmd => !cmd._hidden);\n    if (cmd._hasImplicitHelpCommand()) {\n      // Create a command matching the implicit help command.\n      const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);\n      const helpCommand = cmd.createCommand(helpName)\n        .helpOption(false);\n      helpCommand.description(cmd._helpCommandDescription);\n      if (helpArgs) helpCommand.arguments(helpArgs);\n      visibleCommands.push(helpCommand);\n    }\n    if (this.sortSubcommands) {\n      visibleCommands.sort((a, b) => {\n        // @ts-ignore: overloaded return type\n        return a.name().localeCompare(b.name());\n      });\n    }\n    return visibleCommands;\n  }\n\n  /**\n   * Get an array of the visible options. Includes a placeholder for the implicit help option, if there is one.\n   *\n   * @param {Command} cmd\n   * @returns {Option[]}\n   */\n\n  visibleOptions(cmd) {\n    const visibleOptions = cmd.options.filter((option) => !option.hidden);\n    // Implicit help\n    const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);\n    const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);\n    if (showShortHelpFlag || showLongHelpFlag) {\n      let helpOption;\n      if (!showShortHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);\n      } else if (!showLongHelpFlag) {\n        helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);\n      } else {\n        helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);\n      }\n      visibleOptions.push(helpOption);\n    }\n    if (this.sortOptions) {\n      const getSortKey = (option) => {\n        // WYSIWYG for order displayed in help with short before long, no special handling for negated.\n        return option.short ? option.short.replace(/^-/, '') : option.long.replace(/^--/, '');\n      };\n      visibleOptions.sort((a, b) => {\n        return getSortKey(a).localeCompare(getSortKey(b));\n      });\n    }\n    return visibleOptions;\n  }\n\n  /**\n   * Get an array of the arguments if any have a description.\n   *\n   * @param {Command} cmd\n   * @returns {Argument[]}\n   */\n\n  visibleArguments(cmd) {\n    // Side effect! Apply the legacy descriptions before the arguments are displayed.\n    if (cmd._argsDescription) {\n      cmd._args.forEach(argument => {\n        argument.description = argument.description || cmd._argsDescription[argument.name()] || '';\n      });\n    }\n\n    // If there are any arguments with a description then return all the arguments.\n    if (cmd._args.find(argument => argument.description)) {\n      return cmd._args;\n    }\n    return [];\n  }\n\n  /**\n   * Get the command term to show in the list of subcommands.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandTerm(cmd) {\n    // Legacy. Ignores custom usage string, and nested commands.\n    const args = cmd._args.map(arg => humanReadableArgName(arg)).join(' ');\n    return cmd._name +\n      (cmd._aliases[0] ? '|' + cmd._aliases[0] : '') +\n      (cmd.options.length ? ' [options]' : '') + // simplistic check for non-help option\n      (args ? ' ' + args : '');\n  }\n\n  /**\n   * Get the option term to show in the list of options.\n   *\n   * @param {Option} option\n   * @returns {string}\n   */\n\n  optionTerm(option) {\n    return option.flags;\n  }\n\n  /**\n   * Get the argument term to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @returns {string}\n   */\n\n  argumentTerm(argument) {\n    return argument.name();\n  }\n\n  /**\n   * Get the longest command term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestSubcommandTermLength(cmd, helper) {\n    return helper.visibleCommands(cmd).reduce((max, command) => {\n      return Math.max(max, helper.subcommandTerm(command).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest option term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestOptionTermLength(cmd, helper) {\n    return helper.visibleOptions(cmd).reduce((max, option) => {\n      return Math.max(max, helper.optionTerm(option).length);\n    }, 0);\n  }\n\n  /**\n   * Get the longest argument term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  longestArgumentTermLength(cmd, helper) {\n    return helper.visibleArguments(cmd).reduce((max, argument) => {\n      return Math.max(max, helper.argumentTerm(argument).length);\n    }, 0);\n  }\n\n  /**\n   * Get the command usage to be displayed at the top of the built-in help.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandUsage(cmd) {\n    // Usage\n    let cmdName = cmd._name;\n    if (cmd._aliases[0]) {\n      cmdName = cmdName + '|' + cmd._aliases[0];\n    }\n    let parentCmdNames = '';\n    for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {\n      parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;\n    }\n    return parentCmdNames + cmdName + ' ' + cmd.usage();\n  }\n\n  /**\n   * Get the description for the command.\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  commandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.description();\n  }\n\n  /**\n   * Get the subcommand summary to show in the list of subcommands.\n   * (Fallback to description for backwards compatiblity.)\n   *\n   * @param {Command} cmd\n   * @returns {string}\n   */\n\n  subcommandDescription(cmd) {\n    // @ts-ignore: overloaded return type\n    return cmd.summary() || cmd.description();\n  }\n\n  /**\n   * Get the option description to show in the list of options.\n   *\n   * @param {Option} option\n   * @return {string}\n   */\n\n  optionDescription(option) {\n    const extraInfo = [];\n\n    if (option.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (option.defaultValue !== undefined) {\n      // default for boolean and negated more for programmer than end user,\n      // but show true/false for boolean option as may be for hand-rolled env or config processing.\n      const showDefault = option.required || option.optional ||\n        (option.isBoolean() && typeof option.defaultValue === 'boolean');\n      if (showDefault) {\n        extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);\n      }\n    }\n    // preset for boolean and negated are more for programmer than end user\n    if (option.presetArg !== undefined && option.optional) {\n      extraInfo.push(`preset: ${JSON.stringify(option.presetArg)}`);\n    }\n    if (option.envVar !== undefined) {\n      extraInfo.push(`env: ${option.envVar}`);\n    }\n    if (extraInfo.length > 0) {\n      return `${option.description} (${extraInfo.join(', ')})`;\n    }\n\n    return option.description;\n  }\n\n  /**\n   * Get the argument description to show in the list of arguments.\n   *\n   * @param {Argument} argument\n   * @return {string}\n   */\n\n  argumentDescription(argument) {\n    const extraInfo = [];\n    if (argument.argChoices) {\n      extraInfo.push(\n        // use stringify to match the display of the default value\n        `choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(', ')}`);\n    }\n    if (argument.defaultValue !== undefined) {\n      extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);\n    }\n    if (extraInfo.length > 0) {\n      const extraDescripton = `(${extraInfo.join(', ')})`;\n      if (argument.description) {\n        return `${argument.description} ${extraDescripton}`;\n      }\n      return extraDescripton;\n    }\n    return argument.description;\n  }\n\n  /**\n   * Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}\n   */\n\n  formatHelp(cmd, helper) {\n    const termWidth = helper.padWidth(cmd, helper);\n    const helpWidth = helper.helpWidth || 80;\n    const itemIndentWidth = 2;\n    const itemSeparatorWidth = 2; // between term and description\n    function formatItem(term, description) {\n      if (description) {\n        const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;\n        return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);\n      }\n      return term;\n    }\n    function formatList(textArray) {\n      return textArray.join('\\n').replace(/^/gm, ' '.repeat(itemIndentWidth));\n    }\n\n    // Usage\n    let output = [`Usage: ${helper.commandUsage(cmd)}`, ''];\n\n    // Description\n    const commandDescription = helper.commandDescription(cmd);\n    if (commandDescription.length > 0) {\n      output = output.concat([commandDescription, '']);\n    }\n\n    // Arguments\n    const argumentList = helper.visibleArguments(cmd).map((argument) => {\n      return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));\n    });\n    if (argumentList.length > 0) {\n      output = output.concat(['Arguments:', formatList(argumentList), '']);\n    }\n\n    // Options\n    const optionList = helper.visibleOptions(cmd).map((option) => {\n      return formatItem(helper.optionTerm(option), helper.optionDescription(option));\n    });\n    if (optionList.length > 0) {\n      output = output.concat(['Options:', formatList(optionList), '']);\n    }\n\n    // Commands\n    const commandList = helper.visibleCommands(cmd).map((cmd) => {\n      return formatItem(helper.subcommandTerm(cmd), helper.subcommandDescription(cmd));\n    });\n    if (commandList.length > 0) {\n      output = output.concat(['Commands:', formatList(commandList), '']);\n    }\n\n    return output.join('\\n');\n  }\n\n  /**\n   * Calculate the pad width from the maximum term length.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {number}\n   */\n\n  padWidth(cmd, helper) {\n    return Math.max(\n      helper.longestOptionTermLength(cmd, helper),\n      helper.longestSubcommandTermLength(cmd, helper),\n      helper.longestArgumentTermLength(cmd, helper)\n    );\n  }\n\n  /**\n   * Wrap the given string to width characters per line, with lines after the first indented.\n   * Do not wrap if insufficient room for wrapping (minColumnWidth), or string is manually formatted.\n   *\n   * @param {string} str\n   * @param {number} width\n   * @param {number} indent\n   * @param {number} [minColumnWidth=40]\n   * @return {string}\n   *\n   */\n\n  wrap(str, width, indent, minColumnWidth = 40) {\n    // Detect manually wrapped and indented strings by searching for line breaks\n    // followed by multiple spaces/tabs.\n    if (str.match(/[\\n]\\s+/)) return str;\n    // Do not wrap if not enough room for a wrapped column of text (as could end up with a word per line).\n    const columnWidth = width - indent;\n    if (columnWidth < minColumnWidth) return str;\n\n    const leadingStr = str.slice(0, indent);\n    const columnText = str.slice(indent);\n\n    const indentString = ' '.repeat(indent);\n    const regex = new RegExp('.{1,' + (columnWidth - 1) + '}([\\\\s\\u200B]|$)|[^\\\\s\\u200B]+?([\\\\s\\u200B]|$)', 'g');\n    const lines = columnText.match(regex) || [];\n    return leadingStr + lines.map((line, i) => {\n      if (line.slice(-1) === '\\n') {\n        line = line.slice(0, line.length - 1);\n      }\n      return ((i > 0) ? indentString : '') + line.trimRight();\n    }).join('\\n');\n  }\n}\n\nexports.Help = Help;\n","const { InvalidArgumentError } = require('./error.js');\n\n// @ts-check\n\nclass Option {\n  /**\n   * Initialize a new `Option` with the given `flags` and `description`.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   */\n\n  constructor(flags, description) {\n    this.flags = flags;\n    this.description = description || '';\n\n    this.required = flags.includes('<'); // A value must be supplied when the option is specified.\n    this.optional = flags.includes('['); // A value is optional when the option is specified.\n    // variadic test ignores <value,...> et al which might be used to describe custom splitting of single argument\n    this.variadic = /\\w\\.\\.\\.[>\\]]$/.test(flags); // The option can take multiple values.\n    this.mandatory = false; // The option must have a value after parsing, which usually means it must be specified on command line.\n    const optionFlags = splitOptionFlags(flags);\n    this.short = optionFlags.shortFlag;\n    this.long = optionFlags.longFlag;\n    this.negate = false;\n    if (this.long) {\n      this.negate = this.long.startsWith('--no-');\n    }\n    this.defaultValue = undefined;\n    this.defaultValueDescription = undefined;\n    this.presetArg = undefined;\n    this.envVar = undefined;\n    this.parseArg = undefined;\n    this.hidden = false;\n    this.argChoices = undefined;\n    this.conflictsWith = [];\n    this.implied = undefined;\n  }\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   *\n   * @param {any} value\n   * @param {string} [description]\n   * @return {Option}\n   */\n\n  default(value, description) {\n    this.defaultValue = value;\n    this.defaultValueDescription = description;\n    return this;\n  }\n\n  /**\n   * Preset to use when option used without option-argument, especially optional but also boolean and negated.\n   * The custom processing (parseArg) is called.\n   *\n   * @example\n   * new Option('--color').default('GREYSCALE').preset('RGB');\n   * new Option('--donate [amount]').preset('20').argParser(parseFloat);\n   *\n   * @param {any} arg\n   * @return {Option}\n   */\n\n  preset(arg) {\n    this.presetArg = arg;\n    return this;\n  }\n\n  /**\n   * Add option name(s) that conflict with this option.\n   * An error will be displayed if conflicting options are found during parsing.\n   *\n   * @example\n   * new Option('--rgb').conflicts('cmyk');\n   * new Option('--js').conflicts(['ts', 'jsx']);\n   *\n   * @param {string | string[]} names\n   * @return {Option}\n   */\n\n  conflicts(names) {\n    this.conflictsWith = this.conflictsWith.concat(names);\n    return this;\n  }\n\n  /**\n   * Specify implied option values for when this option is set and the implied options are not.\n   *\n   * The custom processing (parseArg) is not called on the implied values.\n   *\n   * @example\n   * program\n   *   .addOption(new Option('--log', 'write logging information to file'))\n   *   .addOption(new Option('--trace', 'log extra details').implies({ log: 'trace.txt' }));\n   *\n   * @param {Object} impliedOptionValues\n   * @return {Option}\n   */\n  implies(impliedOptionValues) {\n    this.implied = Object.assign(this.implied || {}, impliedOptionValues);\n    return this;\n  }\n\n  /**\n   * Set environment variable to check for option value.\n   * Priority order of option values is default < env < cli\n   *\n   * @param {string} name\n   * @return {Option}\n   */\n\n  env(name) {\n    this.envVar = name;\n    return this;\n  }\n\n  /**\n   * Set the custom handler for processing CLI option arguments into option values.\n   *\n   * @param {Function} [fn]\n   * @return {Option}\n   */\n\n  argParser(fn) {\n    this.parseArg = fn;\n    return this;\n  }\n\n  /**\n   * Whether the option is mandatory and must have a value after parsing.\n   *\n   * @param {boolean} [mandatory=true]\n   * @return {Option}\n   */\n\n  makeOptionMandatory(mandatory = true) {\n    this.mandatory = !!mandatory;\n    return this;\n  }\n\n  /**\n   * Hide option in help.\n   *\n   * @param {boolean} [hide=true]\n   * @return {Option}\n   */\n\n  hideHelp(hide = true) {\n    this.hidden = !!hide;\n    return this;\n  }\n\n  /**\n   * @api private\n   */\n\n  _concatValue(value, previous) {\n    if (previous === this.defaultValue || !Array.isArray(previous)) {\n      return [value];\n    }\n\n    return previous.concat(value);\n  }\n\n  /**\n   * Only allow option value to be one of choices.\n   *\n   * @param {string[]} values\n   * @return {Option}\n   */\n\n  choices(values) {\n    this.argChoices = values.slice();\n    this.parseArg = (arg, previous) => {\n      if (!this.argChoices.includes(arg)) {\n        throw new InvalidArgumentError(`Allowed choices are ${this.argChoices.join(', ')}.`);\n      }\n      if (this.variadic) {\n        return this._concatValue(arg, previous);\n      }\n      return arg;\n    };\n    return this;\n  }\n\n  /**\n   * Return option name.\n   *\n   * @return {string}\n   */\n\n  name() {\n    if (this.long) {\n      return this.long.replace(/^--/, '');\n    }\n    return this.short.replace(/^-/, '');\n  }\n\n  /**\n   * Return option name, in a camelcase format that can be used\n   * as a object attribute key.\n   *\n   * @return {string}\n   * @api private\n   */\n\n  attributeName() {\n    return camelcase(this.name().replace(/^no-/, ''));\n  }\n\n  /**\n   * Check if `arg` matches the short or long flag.\n   *\n   * @param {string} arg\n   * @return {boolean}\n   * @api private\n   */\n\n  is(arg) {\n    return this.short === arg || this.long === arg;\n  }\n\n  /**\n   * Return whether a boolean option.\n   *\n   * Options are one of boolean, negated, required argument, or optional argument.\n   *\n   * @return {boolean}\n   * @api private\n   */\n\n  isBoolean() {\n    return !this.required && !this.optional && !this.negate;\n  }\n}\n\n/**\n * This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.\n */\nclass DualOptions {\n  /**\n   * @param {Option[]} options\n   */\n  constructor(options) {\n    this.positiveOptions = new Map();\n    this.negativeOptions = new Map();\n    this.dualOptions = new Set();\n    options.forEach(option => {\n      if (option.negate) {\n        this.negativeOptions.set(option.attributeName(), option);\n      } else {\n        this.positiveOptions.set(option.attributeName(), option);\n      }\n    });\n    this.negativeOptions.forEach((value, key) => {\n      if (this.positiveOptions.has(key)) {\n        this.dualOptions.add(key);\n      }\n    });\n  }\n\n  /**\n   * Did the value come from the option, and not from possible matching dual option?\n   *\n   * @param {any} value\n   * @param {Option} option\n   * @returns {boolean}\n   */\n  valueFromOption(value, option) {\n    const optionKey = option.attributeName();\n    if (!this.dualOptions.has(optionKey)) return true;\n\n    // Use the value to deduce if (probably) came from the option.\n    const preset = this.negativeOptions.get(optionKey).presetArg;\n    const negativeValue = (preset !== undefined) ? preset : false;\n    return option.negate === (negativeValue === value);\n  }\n}\n\n/**\n * Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @api private\n */\n\nfunction camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  });\n}\n\n/**\n * Split the short and long flag out of something like '-m,--mixed <value>'\n *\n * @api private\n */\n\nfunction splitOptionFlags(flags) {\n  let shortFlag;\n  let longFlag;\n  // Use original very loose parsing to maintain backwards compatibility for now,\n  // which allowed for example unintended `-sw, --short-word` [sic].\n  const flagParts = flags.split(/[ |,]+/);\n  if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1])) shortFlag = flagParts.shift();\n  longFlag = flagParts.shift();\n  // Add support for lone short flag without significantly changing parsing!\n  if (!shortFlag && /^-[^-]$/.test(longFlag)) {\n    shortFlag = longFlag;\n    longFlag = undefined;\n  }\n  return { shortFlag, longFlag };\n}\n\nexports.Option = Option;\nexports.splitOptionFlags = splitOptionFlags;\nexports.DualOptions = DualOptions;\n","const maxDistance = 3;\n\nfunction editDistance(a, b) {\n  // https://en.wikipedia.org/wiki/Damerau–Levenshtein_distance\n  // Calculating optimal string alignment distance, no substring is edited more than once.\n  // (Simple implementation.)\n\n  // Quick early exit, return worst case.\n  if (Math.abs(a.length - b.length) > maxDistance) return Math.max(a.length, b.length);\n\n  // distance between prefix substrings of a and b\n  const d = [];\n\n  // pure deletions turn a into empty string\n  for (let i = 0; i <= a.length; i++) {\n    d[i] = [i];\n  }\n  // pure insertions turn empty string into b\n  for (let j = 0; j <= b.length; j++) {\n    d[0][j] = j;\n  }\n\n  // fill matrix\n  for (let j = 1; j <= b.length; j++) {\n    for (let i = 1; i <= a.length; i++) {\n      let cost = 1;\n      if (a[i - 1] === b[j - 1]) {\n        cost = 0;\n      } else {\n        cost = 1;\n      }\n      d[i][j] = Math.min(\n        d[i - 1][j] + 1, // deletion\n        d[i][j - 1] + 1, // insertion\n        d[i - 1][j - 1] + cost // substitution\n      );\n      // transposition\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);\n      }\n    }\n  }\n\n  return d[a.length][b.length];\n}\n\n/**\n * Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}\n */\n\nfunction suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map(candidate => candidate.slice(2));\n  }\n\n  let similar = [];\n  let bestDistance = maxDistance;\n  const minSimilarity = 0.4;\n  candidates.forEach((candidate) => {\n    if (candidate.length <= 1) return; // no one character guesses\n\n    const distance = editDistance(word, candidate);\n    const length = Math.max(word.length, candidate.length);\n    const similarity = (length - distance) / length;\n    if (similarity > minSimilarity) {\n      if (distance < bestDistance) {\n        // better edit distance, throw away previous worse matches\n        bestDistance = distance;\n        similar = [candidate];\n      } else if (distance === bestDistance) {\n        similar.push(candidate);\n      }\n    }\n  });\n\n  similar.sort((a, b) => a.localeCompare(b));\n  if (searchingOptions) {\n    similar = similar.map(candidate => `--${candidate}`);\n  }\n\n  if (similar.length > 1) {\n    return `\\n(Did you mean one of ${similar.join(', ')}?)`;\n  }\n  if (similar.length === 1) {\n    return `\\n(Did you mean ${similar[0]}?)`;\n  }\n  return '';\n}\n\nexports.suggestSimilar = suggestSimilar;\n","const EventEmitter = require('events').EventEmitter;\nconst childProcess = require('child_process');\nconst path = require('path');\nconst fs = require('fs');\nconst process = require('process');\n\nconst { Argument, humanReadableArgName } = require('./argument.js');\nconst { CommanderError } = require('./error.js');\nconst { Help } = require('./help.js');\nconst { Option, splitOptionFlags, DualOptions } = require('./option.js');\nconst { suggestSimilar } = require('./suggestSimilar');\n\n// @ts-check\n\nclass Command extends EventEmitter {\n  /**\n   * Initialize a new `Command`.\n   *\n   * @param {string} [name]\n   */\n\n  constructor(name) {\n    super();\n    /** @type {Command[]} */\n    this.commands = [];\n    /** @type {Option[]} */\n    this.options = [];\n    this.parent = null;\n    this._allowUnknownOption = false;\n    this._allowExcessArguments = true;\n    /** @type {Argument[]} */\n    this._args = [];\n    /** @type {string[]} */\n    this.args = []; // cli args with options removed\n    this.rawArgs = [];\n    this.processedArgs = []; // like .args but after custom processing and collecting variadic\n    this._scriptPath = null;\n    this._name = name || '';\n    this._optionValues = {};\n    this._optionValueSources = {}; // default < config < env < cli\n    this._storeOptionsAsProperties = false;\n    this._actionHandler = null;\n    this._executableHandler = false;\n    this._executableFile = null; // custom name for executable\n    this._executableDir = null; // custom search directory for subcommands\n    this._defaultCommandName = null;\n    this._exitCallback = null;\n    this._aliases = [];\n    this._combineFlagAndOptionalValue = true;\n    this._description = '';\n    this._summary = '';\n    this._argsDescription = undefined; // legacy\n    this._enablePositionalOptions = false;\n    this._passThroughOptions = false;\n    this._lifeCycleHooks = {}; // a hash of arrays\n    /** @type {boolean | string} */\n    this._showHelpAfterError = false;\n    this._showSuggestionAfterError = true;\n\n    // see .configureOutput() for docs\n    this._outputConfiguration = {\n      writeOut: (str) => process.stdout.write(str),\n      writeErr: (str) => process.stderr.write(str),\n      getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : undefined,\n      getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : undefined,\n      outputError: (str, write) => write(str)\n    };\n\n    this._hidden = false;\n    this._hasHelpOption = true;\n    this._helpFlags = '-h, --help';\n    this._helpDescription = 'display help for command';\n    this._helpShortFlag = '-h';\n    this._helpLongFlag = '--help';\n    this._addImplicitHelpCommand = undefined; // Deliberately undefined, not decided whether true or false\n    this._helpCommandName = 'help';\n    this._helpCommandnameAndArgs = 'help [command]';\n    this._helpCommandDescription = 'display help for command';\n    this._helpConfiguration = {};\n  }\n\n  /**\n   * Copy settings that are useful to have in common across root command and subcommands.\n   *\n   * (Used internally when adding a command using `.command()` so subcommands inherit parent settings.)\n   *\n   * @param {Command} sourceCommand\n   * @return {Command} `this` command for chaining\n   */\n  copyInheritedSettings(sourceCommand) {\n    this._outputConfiguration = sourceCommand._outputConfiguration;\n    this._hasHelpOption = sourceCommand._hasHelpOption;\n    this._helpFlags = sourceCommand._helpFlags;\n    this._helpDescription = sourceCommand._helpDescription;\n    this._helpShortFlag = sourceCommand._helpShortFlag;\n    this._helpLongFlag = sourceCommand._helpLongFlag;\n    this._helpCommandName = sourceCommand._helpCommandName;\n    this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;\n    this._helpCommandDescription = sourceCommand._helpCommandDescription;\n    this._helpConfiguration = sourceCommand._helpConfiguration;\n    this._exitCallback = sourceCommand._exitCallback;\n    this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;\n    this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;\n    this._allowExcessArguments = sourceCommand._allowExcessArguments;\n    this._enablePositionalOptions = sourceCommand._enablePositionalOptions;\n    this._showHelpAfterError = sourceCommand._showHelpAfterError;\n    this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;\n\n    return this;\n  }\n\n  /**\n   * Define a command.\n   *\n   * There are two styles of command: pay attention to where to put the description.\n   *\n   * @example\n   * // Command implemented using action handler (description is supplied separately to `.command`)\n   * program\n   *   .command('clone <source> [destination]')\n   *   .description('clone a repository into a newly created directory')\n   *   .action((source, destination) => {\n   *     console.log('clone command called');\n   *   });\n   *\n   * // Command implemented using separate executable file (description is second parameter to `.command`)\n   * program\n   *   .command('start <service>', 'start named service')\n   *   .command('stop [service]', 'stop named service, or all if no name supplied');\n   *\n   * @param {string} nameAndArgs - command name and arguments, args are `<required>` or `[optional]` and last may also be `variadic...`\n   * @param {Object|string} [actionOptsOrExecDesc] - configuration options (for action), or description (for executable)\n   * @param {Object} [execOpts] - configuration options (for executable)\n   * @return {Command} returns new command for action handler, or `this` for executable command\n   */\n\n  command(nameAndArgs, actionOptsOrExecDesc, execOpts) {\n    let desc = actionOptsOrExecDesc;\n    let opts = execOpts;\n    if (typeof desc === 'object' && desc !== null) {\n      opts = desc;\n      desc = null;\n    }\n    opts = opts || {};\n    const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);\n\n    const cmd = this.createCommand(name);\n    if (desc) {\n      cmd.description(desc);\n      cmd._executableHandler = true;\n    }\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    cmd._hidden = !!(opts.noHelp || opts.hidden); // noHelp is deprecated old name for hidden\n    cmd._executableFile = opts.executableFile || null; // Custom name for executable file, set missing to null to match constructor\n    if (args) cmd.arguments(args);\n    this.commands.push(cmd);\n    cmd.parent = this;\n    cmd.copyInheritedSettings(this);\n\n    if (desc) return this;\n    return cmd;\n  }\n\n  /**\n   * Factory routine to create a new unattached command.\n   *\n   * See .command() for creating an attached subcommand, which uses this routine to\n   * create the command. You can override createCommand to customise subcommands.\n   *\n   * @param {string} [name]\n   * @return {Command} new command\n   */\n\n  createCommand(name) {\n    return new Command(name);\n  }\n\n  /**\n   * You can customise the help with a subclass of Help by overriding createHelp,\n   * or by overriding Help properties using configureHelp().\n   *\n   * @return {Help}\n   */\n\n  createHelp() {\n    return Object.assign(new Help(), this.configureHelp());\n  }\n\n  /**\n   * You can customise the help by overriding Help properties using configureHelp(),\n   * or with a subclass of Help by overriding createHelp().\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureHelp(configuration) {\n    if (configuration === undefined) return this._helpConfiguration;\n\n    this._helpConfiguration = configuration;\n    return this;\n  }\n\n  /**\n   * The default output goes to stdout and stderr. You can customise this for special\n   * applications. You can also customise the display of errors by overriding outputError.\n   *\n   * The configuration properties are all functions:\n   *\n   *     // functions to change where being written, stdout and stderr\n   *     writeOut(str)\n   *     writeErr(str)\n   *     // matching functions to specify width for wrapping help\n   *     getOutHelpWidth()\n   *     getErrHelpWidth()\n   *     // functions based on what is being written out\n   *     outputError(str, write) // used for displaying errors, and not used for displaying help\n   *\n   * @param {Object} [configuration] - configuration options\n   * @return {Command|Object} `this` command for chaining, or stored configuration\n   */\n\n  configureOutput(configuration) {\n    if (configuration === undefined) return this._outputConfiguration;\n\n    Object.assign(this._outputConfiguration, configuration);\n    return this;\n  }\n\n  /**\n   * Display the help or a custom message after an error occurs.\n   *\n   * @param {boolean|string} [displayHelp]\n   * @return {Command} `this` command for chaining\n   */\n  showHelpAfterError(displayHelp = true) {\n    if (typeof displayHelp !== 'string') displayHelp = !!displayHelp;\n    this._showHelpAfterError = displayHelp;\n    return this;\n  }\n\n  /**\n   * Display suggestion of similar commands for unknown commands, or options for unknown options.\n   *\n   * @param {boolean} [displaySuggestion]\n   * @return {Command} `this` command for chaining\n   */\n  showSuggestionAfterError(displaySuggestion = true) {\n    this._showSuggestionAfterError = !!displaySuggestion;\n    return this;\n  }\n\n  /**\n   * Add a prepared subcommand.\n   *\n   * See .command() for creating an attached subcommand which inherits settings from its parent.\n   *\n   * @param {Command} cmd - new subcommand\n   * @param {Object} [opts] - configuration options\n   * @return {Command} `this` command for chaining\n   */\n\n  addCommand(cmd, opts) {\n    if (!cmd._name) {\n      throw new Error(`Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()`);\n    }\n\n    opts = opts || {};\n    if (opts.isDefault) this._defaultCommandName = cmd._name;\n    if (opts.noHelp || opts.hidden) cmd._hidden = true; // modifying passed command due to existing implementation\n\n    this.commands.push(cmd);\n    cmd.parent = this;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached argument.\n   *\n   * See .argument() for creating an attached argument, which uses this routine to\n   * create the argument. You can override createArgument to return a custom argument.\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @return {Argument} new argument\n   */\n\n  createArgument(name, description) {\n    return new Argument(name, description);\n  }\n\n  /**\n   * Define argument syntax for command.\n   *\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   *\n   * @example\n   * program.argument('<input-file>');\n   * program.argument('[output-file]');\n   *\n   * @param {string} name\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom argument processing function\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n  argument(name, description, fn, defaultValue) {\n    const argument = this.createArgument(name, description);\n    if (typeof fn === 'function') {\n      argument.default(defaultValue).argParser(fn);\n    } else {\n      argument.default(fn);\n    }\n    this.addArgument(argument);\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding multiple at once (without descriptions).\n   *\n   * See also .argument().\n   *\n   * @example\n   * program.arguments('<cmd> [env]');\n   *\n   * @param {string} names\n   * @return {Command} `this` command for chaining\n   */\n\n  arguments(names) {\n    names.split(/ +/).forEach((detail) => {\n      this.argument(detail);\n    });\n    return this;\n  }\n\n  /**\n   * Define argument syntax for command, adding a prepared argument.\n   *\n   * @param {Argument} argument\n   * @return {Command} `this` command for chaining\n   */\n  addArgument(argument) {\n    const previousArgument = this._args.slice(-1)[0];\n    if (previousArgument && previousArgument.variadic) {\n      throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);\n    }\n    if (argument.required && argument.defaultValue !== undefined && argument.parseArg === undefined) {\n      throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);\n    }\n    this._args.push(argument);\n    return this;\n  }\n\n  /**\n   * Override default decision whether to add implicit help command.\n   *\n   *    addHelpCommand() // force on\n   *    addHelpCommand(false); // force off\n   *    addHelpCommand('help [cmd]', 'display help for [cmd]'); // force on with custom details\n   *\n   * @return {Command} `this` command for chaining\n   */\n\n  addHelpCommand(enableOrNameAndArgs, description) {\n    if (enableOrNameAndArgs === false) {\n      this._addImplicitHelpCommand = false;\n    } else {\n      this._addImplicitHelpCommand = true;\n      if (typeof enableOrNameAndArgs === 'string') {\n        this._helpCommandName = enableOrNameAndArgs.split(' ')[0];\n        this._helpCommandnameAndArgs = enableOrNameAndArgs;\n      }\n      this._helpCommandDescription = description || this._helpCommandDescription;\n    }\n    return this;\n  }\n\n  /**\n   * @return {boolean}\n   * @api private\n   */\n\n  _hasImplicitHelpCommand() {\n    if (this._addImplicitHelpCommand === undefined) {\n      return this.commands.length && !this._actionHandler && !this._findCommand('help');\n    }\n    return this._addImplicitHelpCommand;\n  }\n\n  /**\n   * Add hook for life cycle event.\n   *\n   * @param {string} event\n   * @param {Function} listener\n   * @return {Command} `this` command for chaining\n   */\n\n  hook(event, listener) {\n    const allowedValues = ['preAction', 'postAction'];\n    if (!allowedValues.includes(event)) {\n      throw new Error(`Unexpected value for event passed to hook : '${event}'.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    if (this._lifeCycleHooks[event]) {\n      this._lifeCycleHooks[event].push(listener);\n    } else {\n      this._lifeCycleHooks[event] = [listener];\n    }\n    return this;\n  }\n\n  /**\n   * Register callback to use as replacement for calling process.exit.\n   *\n   * @param {Function} [fn] optional callback which will be passed a CommanderError, defaults to throwing\n   * @return {Command} `this` command for chaining\n   */\n\n  exitOverride(fn) {\n    if (fn) {\n      this._exitCallback = fn;\n    } else {\n      this._exitCallback = (err) => {\n        if (err.code !== 'commander.executeSubCommandAsync') {\n          throw err;\n        } else {\n          // Async callback from spawn events, not useful to throw.\n        }\n      };\n    }\n    return this;\n  }\n\n  /**\n   * Call process.exit, and _exitCallback if defined.\n   *\n   * @param {number} exitCode exit code for using with process.exit\n   * @param {string} code an id string representing the error\n   * @param {string} message human-readable description of the error\n   * @return never\n   * @api private\n   */\n\n  _exit(exitCode, code, message) {\n    if (this._exitCallback) {\n      this._exitCallback(new CommanderError(exitCode, code, message));\n      // Expecting this line is not reached.\n    }\n    process.exit(exitCode);\n  }\n\n  /**\n   * Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining\n   */\n\n  action(fn) {\n    const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this._args.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      } else {\n        actionArgs[expectedArgsCount] = this.opts();\n      }\n      actionArgs.push(this);\n\n      return fn.apply(this, actionArgs);\n    };\n    this._actionHandler = listener;\n    return this;\n  }\n\n  /**\n   * Factory routine to create a new unattached option.\n   *\n   * See .option() for creating an attached option, which uses this routine to\n   * create the option. You can override createOption to return a custom option.\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @return {Option} new option\n   */\n\n  createOption(flags, description) {\n    return new Option(flags, description);\n  }\n\n  /**\n   * Add an option.\n   *\n   * @param {Option} option\n   * @return {Command} `this` command for chaining\n   */\n  addOption(option) {\n    const oname = option.name();\n    const name = option.attributeName();\n\n    // store default value\n    if (option.negate) {\n      // --no-foo is special and defaults foo to true, unless a --foo option is already defined\n      const positiveLongFlag = option.long.replace(/^--no-/, '--');\n      if (!this._findOption(positiveLongFlag)) {\n        this.setOptionValueWithSource(name, option.defaultValue === undefined ? true : option.defaultValue, 'default');\n      }\n    } else if (option.defaultValue !== undefined) {\n      this.setOptionValueWithSource(name, option.defaultValue, 'default');\n    }\n\n    // register the option\n    this.options.push(option);\n\n    // handler for cli and env supplied values\n    const handleOptionValue = (val, invalidValueMessage, valueSource) => {\n      // val is null for optional option used without an optional-argument.\n      // val is undefined for boolean and negated option.\n      if (val == null && option.presetArg !== undefined) {\n        val = option.presetArg;\n      }\n\n      // custom processing\n      const oldValue = this.getOptionValue(name);\n      if (val !== null && option.parseArg) {\n        try {\n          val = option.parseArg(val, oldValue);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `${invalidValueMessage} ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      } else if (val !== null && option.variadic) {\n        val = option._concatValue(val, oldValue);\n      }\n\n      // Fill-in appropriate missing values. Long winded but easy to follow.\n      if (val == null) {\n        if (option.negate) {\n          val = false;\n        } else if (option.isBoolean() || option.optional) {\n          val = true;\n        } else {\n          val = ''; // not normal, parseArg might have failed or be a mock function for testing\n        }\n      }\n      this.setOptionValueWithSource(name, val, valueSource);\n    };\n\n    this.on('option:' + oname, (val) => {\n      const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;\n      handleOptionValue(val, invalidValueMessage, 'cli');\n    });\n\n    if (option.envVar) {\n      this.on('optionEnv:' + oname, (val) => {\n        const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;\n        handleOptionValue(val, invalidValueMessage, 'env');\n      });\n    }\n\n    return this;\n  }\n\n  /**\n   * Internal implementation shared by .option() and .requiredOption()\n   *\n   * @api private\n   */\n  _optionEx(config, flags, description, fn, defaultValue) {\n    if (typeof flags === 'object' && flags instanceof Option) {\n      throw new Error('To add an Option object use addOption() instead of option() or requiredOption()');\n    }\n    const option = this.createOption(flags, description);\n    option.makeOptionMandatory(!!config.mandatory);\n    if (typeof fn === 'function') {\n      option.default(defaultValue).argParser(fn);\n    } else if (fn instanceof RegExp) {\n      // deprecated\n      const regex = fn;\n      fn = (val, def) => {\n        const m = regex.exec(val);\n        return m ? m[0] : def;\n      };\n      option.default(defaultValue).argParser(fn);\n    } else {\n      option.default(fn);\n    }\n\n    return this.addOption(option);\n  }\n\n  /**\n   * Define option with `flags`, `description` and optional\n   * coercion `fn`.\n   *\n   * The `flags` string contains the short and/or long flags,\n   * separated by comma, a pipe or space. The following are all valid\n   * all will output this way when `--help` is used.\n   *\n   *     \"-p, --pepper\"\n   *     \"-p|--pepper\"\n   *     \"-p --pepper\"\n   *\n   * @example\n   * // simple boolean defaulting to undefined\n   * program.option('-p, --pepper', 'add pepper');\n   *\n   * program.pepper\n   * // => undefined\n   *\n   * --pepper\n   * program.pepper\n   * // => true\n   *\n   * // simple boolean defaulting to true (unless non-negated option is also defined)\n   * program.option('-C, --no-cheese', 'remove cheese');\n   *\n   * program.cheese\n   * // => true\n   *\n   * --no-cheese\n   * program.cheese\n   * // => false\n   *\n   * // required argument\n   * program.option('-C, --chdir <path>', 'change the working directory');\n   *\n   * --chdir /tmp\n   * program.chdir\n   * // => \"/tmp\"\n   *\n   * // optional argument\n   * program.option('-c, --cheese [type]', 'add cheese [marble]');\n   *\n   * @param {string} flags\n   * @param {string} [description]\n   * @param {Function|*} [fn] - custom option processing function or default value\n   * @param {*} [defaultValue]\n   * @return {Command} `this` command for chaining\n   */\n\n  option(flags, description, fn, defaultValue) {\n    return this._optionEx({}, flags, description, fn, defaultValue);\n  }\n\n  /**\n  * Add a required option which must have a value after parsing. This usually means\n  * the option must be specified on the command line. (Otherwise the same as .option().)\n  *\n  * The `flags` string contains the short and/or long flags, separated by comma, a pipe or space.\n  *\n  * @param {string} flags\n  * @param {string} [description]\n  * @param {Function|*} [fn] - custom option processing function or default value\n  * @param {*} [defaultValue]\n  * @return {Command} `this` command for chaining\n  */\n\n  requiredOption(flags, description, fn, defaultValue) {\n    return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);\n  }\n\n  /**\n   * Alter parsing of short flags with optional values.\n   *\n   * @example\n   * // for `.option('-f,--flag [value]'):\n   * program.combineFlagAndOptionalValue(true);  // `-f80` is treated like `--flag=80`, this is the default behaviour\n   * program.combineFlagAndOptionalValue(false) // `-fb` is treated like `-f -b`\n   *\n   * @param {Boolean} [combine=true] - if `true` or omitted, an optional value can be specified directly after the flag.\n   */\n  combineFlagAndOptionalValue(combine = true) {\n    this._combineFlagAndOptionalValue = !!combine;\n    return this;\n  }\n\n  /**\n   * Allow unknown options on the command line.\n   *\n   * @param {Boolean} [allowUnknown=true] - if `true` or omitted, no error will be thrown\n   * for unknown options.\n   */\n  allowUnknownOption(allowUnknown = true) {\n    this._allowUnknownOption = !!allowUnknown;\n    return this;\n  }\n\n  /**\n   * Allow excess command-arguments on the command line. Pass false to make excess arguments an error.\n   *\n   * @param {Boolean} [allowExcess=true] - if `true` or omitted, no error will be thrown\n   * for excess arguments.\n   */\n  allowExcessArguments(allowExcess = true) {\n    this._allowExcessArguments = !!allowExcess;\n    return this;\n  }\n\n  /**\n   * Enable positional options. Positional means global options are specified before subcommands which lets\n   * subcommands reuse the same option names, and also enables subcommands to turn on passThroughOptions.\n   * The default behaviour is non-positional and global options may appear anywhere on the command line.\n   *\n   * @param {Boolean} [positional=true]\n   */\n  enablePositionalOptions(positional = true) {\n    this._enablePositionalOptions = !!positional;\n    return this;\n  }\n\n  /**\n   * Pass through options that come after command-arguments rather than treat them as command-options,\n   * so actual command-options come before command-arguments. Turning this on for a subcommand requires\n   * positional options to have been enabled on the program (parent commands).\n   * The default behaviour is non-positional and options may appear before or after command-arguments.\n   *\n   * @param {Boolean} [passThrough=true]\n   * for unknown options.\n   */\n  passThroughOptions(passThrough = true) {\n    this._passThroughOptions = !!passThrough;\n    if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {\n      throw new Error('passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)');\n    }\n    return this;\n  }\n\n  /**\n    * Whether to store option values as properties on command object,\n    * or store separately (specify false). In both cases the option values can be accessed using .opts().\n    *\n    * @param {boolean} [storeAsProperties=true]\n    * @return {Command} `this` command for chaining\n    */\n\n  storeOptionsAsProperties(storeAsProperties = true) {\n    this._storeOptionsAsProperties = !!storeAsProperties;\n    if (this.options.length) {\n      throw new Error('call .storeOptionsAsProperties() before adding options');\n    }\n    return this;\n  }\n\n  /**\n   * Retrieve option value.\n   *\n   * @param {string} key\n   * @return {Object} value\n   */\n\n  getOptionValue(key) {\n    if (this._storeOptionsAsProperties) {\n      return this[key];\n    }\n    return this._optionValues[key];\n  }\n\n  /**\n   * Store option value.\n   *\n   * @param {string} key\n   * @param {Object} value\n   * @return {Command} `this` command for chaining\n   */\n\n  setOptionValue(key, value) {\n    if (this._storeOptionsAsProperties) {\n      this[key] = value;\n    } else {\n      this._optionValues[key] = value;\n    }\n    return this;\n  }\n\n  /**\n   * Store option value and where the value came from.\n    *\n    * @param {string} key\n    * @param {Object} value\n    * @param {string} source - expected values are default/config/env/cli\n    * @return {Command} `this` command for chaining\n    */\n\n  setOptionValueWithSource(key, value, source) {\n    this.setOptionValue(key, value);\n    this._optionValueSources[key] = source;\n    return this;\n  }\n\n  /**\n    * Get source of option value.\n    * Expected values are default | config | env | cli\n    *\n    * @param {string} key\n    * @return {string}\n    */\n\n  getOptionValueSource(key) {\n    return this._optionValueSources[key];\n  }\n\n  /**\n   * Get user arguments from implied or explicit arguments.\n   * Side-effects: set _scriptPath if args included script. Used for default program name, and subcommand searches.\n   *\n   * @api private\n   */\n\n  _prepareUserArgs(argv, parseOptions) {\n    if (argv !== undefined && !Array.isArray(argv)) {\n      throw new Error('first parameter to parse must be array or undefined');\n    }\n    parseOptions = parseOptions || {};\n\n    // Default to using process.argv\n    if (argv === undefined) {\n      argv = process.argv;\n      // @ts-ignore: unknown property\n      if (process.versions && process.versions.electron) {\n        parseOptions.from = 'electron';\n      }\n    }\n    this.rawArgs = argv.slice();\n\n    // make it a little easier for callers by supporting various argv conventions\n    let userArgs;\n    switch (parseOptions.from) {\n      case undefined:\n      case 'node':\n        this._scriptPath = argv[1];\n        userArgs = argv.slice(2);\n        break;\n      case 'electron':\n        // @ts-ignore: unknown property\n        if (process.defaultApp) {\n          this._scriptPath = argv[1];\n          userArgs = argv.slice(2);\n        } else {\n          userArgs = argv.slice(1);\n        }\n        break;\n      case 'user':\n        userArgs = argv.slice(0);\n        break;\n      default:\n        throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);\n    }\n\n    // Find default name for program from arguments.\n    if (!this._name && this._scriptPath) this.nameFromFilename(this._scriptPath);\n    this._name = this._name || 'program';\n\n    return userArgs;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * program.parse(process.argv);\n   * program.parse(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * program.parse(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv] - optional, defaults to process.argv\n   * @param {Object} [parseOptions] - optionally specify style of options with from: node/user/electron\n   * @param {string} [parseOptions.from] - where the args are from: 'node', 'user', 'electron'\n   * @return {Command} `this` command for chaining\n   */\n\n  parse(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Parse `argv`, setting options and invoking commands when defined.\n   *\n   * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.\n   *\n   * The default expectation is that the arguments are from node and have the application as argv[0]\n   * and the script being run in argv[1], with user parameters after that.\n   *\n   * @example\n   * await program.parseAsync(process.argv);\n   * await program.parseAsync(); // implicitly use process.argv and auto-detect node vs electron conventions\n   * await program.parseAsync(my-args, { from: 'user' }); // just user supplied arguments, nothing special about argv[0]\n   *\n   * @param {string[]} [argv]\n   * @param {Object} [parseOptions]\n   * @param {string} parseOptions.from - where the args are from: 'node', 'user', 'electron'\n   * @return {Promise}\n   */\n\n  async parseAsync(argv, parseOptions) {\n    const userArgs = this._prepareUserArgs(argv, parseOptions);\n    await this._parseCommand([], userArgs);\n\n    return this;\n  }\n\n  /**\n   * Execute a sub-command executable.\n   *\n   * @api private\n   */\n\n  _executeSubCommand(subcommand, args) {\n    args = args.slice();\n    let launchWithNode = false; // Use node for source targets so do not need to get permissions correct, and on Windows.\n    const sourceExt = ['.js', '.ts', '.tsx', '.mjs', '.cjs'];\n\n    function findFile(baseDir, baseName) {\n      // Look for specified file\n      const localBin = path.resolve(baseDir, baseName);\n      if (fs.existsSync(localBin)) return localBin;\n\n      // Stop looking if candidate already has an expected extension.\n      if (sourceExt.includes(path.extname(baseName))) return undefined;\n\n      // Try all the extensions.\n      const foundExt = sourceExt.find(ext => fs.existsSync(`${localBin}${ext}`));\n      if (foundExt) return `${localBin}${foundExt}`;\n\n      return undefined;\n    }\n\n    // Not checking for help first. Unlikely to have mandatory and executable, and can't robustly test for help flags in external command.\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // executableFile and executableDir might be full path, or just a name\n    let executableFile = subcommand._executableFile || `${this._name}-${subcommand._name}`;\n    let executableDir = this._executableDir || '';\n    if (this._scriptPath) {\n      let resolvedScriptPath; // resolve possible symlink for installed npm binary\n      try {\n        resolvedScriptPath = fs.realpathSync(this._scriptPath);\n      } catch (err) {\n        resolvedScriptPath = this._scriptPath;\n      }\n      executableDir = path.resolve(path.dirname(resolvedScriptPath), executableDir);\n    }\n\n    // Look for a local file in preference to a command in PATH.\n    if (executableDir) {\n      let localFile = findFile(executableDir, executableFile);\n\n      // Legacy search using prefix of script name instead of command name\n      if (!localFile && !subcommand._executableFile && this._scriptPath) {\n        const legacyName = path.basename(this._scriptPath, path.extname(this._scriptPath));\n        if (legacyName !== this._name) {\n          localFile = findFile(executableDir, `${legacyName}-${subcommand._name}`);\n        }\n      }\n      executableFile = localFile || executableFile;\n    }\n\n    launchWithNode = sourceExt.includes(path.extname(executableFile));\n\n    let proc;\n    if (process.platform !== 'win32') {\n      if (launchWithNode) {\n        args.unshift(executableFile);\n        // add executable arguments to spawn\n        args = incrementNodeInspectorPort(process.execArgv).concat(args);\n\n        proc = childProcess.spawn(process.argv[0], args, { stdio: 'inherit' });\n      } else {\n        proc = childProcess.spawn(executableFile, args, { stdio: 'inherit' });\n      }\n    } else {\n      args.unshift(executableFile);\n      // add executable arguments to spawn\n      args = incrementNodeInspectorPort(process.execArgv).concat(args);\n      proc = childProcess.spawn(process.execPath, args, { stdio: 'inherit' });\n    }\n\n    if (!proc.killed) { // testing mainly to avoid leak warnings during unit tests with mocked spawn\n      const signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];\n      signals.forEach((signal) => {\n        // @ts-ignore\n        process.on(signal, () => {\n          if (proc.killed === false && proc.exitCode === null) {\n            proc.kill(signal);\n          }\n        });\n      });\n    }\n\n    // By default terminate process when spawned process terminates.\n    // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!\n    const exitCallback = this._exitCallback;\n    if (!exitCallback) {\n      proc.on('close', process.exit.bind(process));\n    } else {\n      proc.on('close', () => {\n        exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));\n      });\n    }\n    proc.on('error', (err) => {\n      // @ts-ignore\n      if (err.code === 'ENOENT') {\n        const executableDirMessage = executableDir\n          ? `searched for local subcommand relative to directory '${executableDir}'`\n          : 'no directory for search for local subcommand, use .executableDir() to supply a custom directory';\n        const executableMissing = `'${executableFile}' does not exist\n - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - ${executableDirMessage}`;\n        throw new Error(executableMissing);\n      // @ts-ignore\n      } else if (err.code === 'EACCES') {\n        throw new Error(`'${executableFile}' not executable`);\n      }\n      if (!exitCallback) {\n        process.exit(1);\n      } else {\n        const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');\n        wrappedError.nestedError = err;\n        exitCallback(wrappedError);\n      }\n    });\n\n    // Store the reference to the child process\n    this.runningCommand = proc;\n  }\n\n  /**\n   * @api private\n   */\n\n  _dispatchSubcommand(commandName, operands, unknown) {\n    const subCommand = this._findCommand(commandName);\n    if (!subCommand) this.help({ error: true });\n\n    if (subCommand._executableHandler) {\n      this._executeSubCommand(subCommand, operands.concat(unknown));\n    } else {\n      return subCommand._parseCommand(operands, unknown);\n    }\n  }\n\n  /**\n   * Check this.args against expected this._args.\n   *\n   * @api private\n   */\n\n  _checkNumberOfArguments() {\n    // too few\n    this._args.forEach((arg, i) => {\n      if (arg.required && this.args[i] == null) {\n        this.missingArgument(arg.name());\n      }\n    });\n    // too many\n    if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {\n      return;\n    }\n    if (this.args.length > this._args.length) {\n      this._excessArguments(this.args);\n    }\n  }\n\n  /**\n   * Process this.args using this._args and save as this.processedArgs!\n   *\n   * @api private\n   */\n\n  _processArguments() {\n    const myParseArg = (argument, value, previous) => {\n      // Extra processing for nice error message on parsing failure.\n      let parsedValue = value;\n      if (value !== null && argument.parseArg) {\n        try {\n          parsedValue = argument.parseArg(value, previous);\n        } catch (err) {\n          if (err.code === 'commander.invalidArgument') {\n            const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;\n            this.error(message, { exitCode: err.exitCode, code: err.code });\n          }\n          throw err;\n        }\n      }\n      return parsedValue;\n    };\n\n    this._checkNumberOfArguments();\n\n    const processedArgs = [];\n    this._args.forEach((declaredArg, index) => {\n      let value = declaredArg.defaultValue;\n      if (declaredArg.variadic) {\n        // Collect together remaining arguments for passing together as an array.\n        if (index < this.args.length) {\n          value = this.args.slice(index);\n          if (declaredArg.parseArg) {\n            value = value.reduce((processed, v) => {\n              return myParseArg(declaredArg, v, processed);\n            }, declaredArg.defaultValue);\n          }\n        } else if (value === undefined) {\n          value = [];\n        }\n      } else if (index < this.args.length) {\n        value = this.args[index];\n        if (declaredArg.parseArg) {\n          value = myParseArg(declaredArg, value, declaredArg.defaultValue);\n        }\n      }\n      processedArgs[index] = value;\n    });\n    this.processedArgs = processedArgs;\n  }\n\n  /**\n   * Once we have a promise we chain, but call synchronously until then.\n   *\n   * @param {Promise|undefined} promise\n   * @param {Function} fn\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCall(promise, fn) {\n    // thenable\n    if (promise && promise.then && typeof promise.then === 'function') {\n      // already have a promise, chain callback\n      return promise.then(() => fn());\n    }\n    // callback might return a promise\n    return fn();\n  }\n\n  /**\n   *\n   * @param {Promise|undefined} promise\n   * @param {string} event\n   * @return {Promise|undefined}\n   * @api private\n   */\n\n  _chainOrCallHooks(promise, event) {\n    let result = promise;\n    const hooks = [];\n    getCommandAndParents(this)\n      .reverse()\n      .filter(cmd => cmd._lifeCycleHooks[event] !== undefined)\n      .forEach(hookedCommand => {\n        hookedCommand._lifeCycleHooks[event].forEach((callback) => {\n          hooks.push({ hookedCommand, callback });\n        });\n      });\n    if (event === 'postAction') {\n      hooks.reverse();\n    }\n\n    hooks.forEach((hookDetail) => {\n      result = this._chainOrCall(result, () => {\n        return hookDetail.callback(hookDetail.hookedCommand, this);\n      });\n    });\n    return result;\n  }\n\n  /**\n   * Process arguments in context of this command.\n   * Returns action result, in case it is a promise.\n   *\n   * @api private\n   */\n\n  _parseCommand(operands, unknown) {\n    const parsed = this.parseOptions(unknown);\n    this._parseOptionsEnv(); // after cli, so parseArg not called on both cli and env\n    this._parseOptionsImplied();\n    operands = operands.concat(parsed.operands);\n    unknown = parsed.unknown;\n    this.args = operands.concat(unknown);\n\n    if (operands && this._findCommand(operands[0])) {\n      return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);\n    }\n    if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {\n      if (operands.length === 1) {\n        this.help();\n      }\n      return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);\n    }\n    if (this._defaultCommandName) {\n      outputHelpIfRequested(this, unknown); // Run the help for default command from parent rather than passing to default command\n      return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);\n    }\n    if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {\n      // probably missing subcommand and no handler, user needs help (and exit)\n      this.help({ error: true });\n    }\n\n    outputHelpIfRequested(this, parsed.unknown);\n    this._checkForMissingMandatoryOptions();\n    this._checkForConflictingOptions();\n\n    // We do not always call this check to avoid masking a \"better\" error, like unknown command.\n    const checkForUnknownOptions = () => {\n      if (parsed.unknown.length > 0) {\n        this.unknownOption(parsed.unknown[0]);\n      }\n    };\n\n    const commandEvent = `command:${this.name()}`;\n    if (this._actionHandler) {\n      checkForUnknownOptions();\n      this._processArguments();\n\n      let actionResult;\n      actionResult = this._chainOrCallHooks(actionResult, 'preAction');\n      actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));\n      if (this.parent) {\n        actionResult = this._chainOrCall(actionResult, () => {\n          this.parent.emit(commandEvent, operands, unknown); // legacy\n        });\n      }\n      actionResult = this._chainOrCallHooks(actionResult, 'postAction');\n      return actionResult;\n    }\n    if (this.parent && this.parent.listenerCount(commandEvent)) {\n      checkForUnknownOptions();\n      this._processArguments();\n      this.parent.emit(commandEvent, operands, unknown); // legacy\n    } else if (operands.length) {\n      if (this._findCommand('*')) { // legacy default command\n        return this._dispatchSubcommand('*', operands, unknown);\n      }\n      if (this.listenerCount('command:*')) {\n        // skip option check, emit event for possible misspelling suggestion\n        this.emit('command:*', operands, unknown);\n      } else if (this.commands.length) {\n        this.unknownCommand();\n      } else {\n        checkForUnknownOptions();\n        this._processArguments();\n      }\n    } else if (this.commands.length) {\n      checkForUnknownOptions();\n      // This command has subcommands and nothing hooked up at this level, so display help (and exit).\n      this.help({ error: true });\n    } else {\n      checkForUnknownOptions();\n      this._processArguments();\n      // fall through for caller to handle after calling .parse()\n    }\n  }\n\n  /**\n   * Find matching command.\n   *\n   * @api private\n   */\n  _findCommand(name) {\n    if (!name) return undefined;\n    return this.commands.find(cmd => cmd._name === name || cmd._aliases.includes(name));\n  }\n\n  /**\n   * Return an option matching `arg` if any.\n   *\n   * @param {string} arg\n   * @return {Option}\n   * @api private\n   */\n\n  _findOption(arg) {\n    return this.options.find(option => option.is(arg));\n  }\n\n  /**\n   * Display an error message if a mandatory option does not have a value.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n\n  _checkForMissingMandatoryOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd.options.forEach((anOption) => {\n        if (anOption.mandatory && (cmd.getOptionValue(anOption.attributeName()) === undefined)) {\n          cmd.missingMandatoryOptionValue(anOption);\n        }\n      });\n    }\n  }\n\n  /**\n   * Display an error message if conflicting options are used together in this.\n   *\n   * @api private\n   */\n  _checkForConflictingLocalOptions() {\n    const definedNonDefaultOptions = this.options.filter(\n      (option) => {\n        const optionKey = option.attributeName();\n        if (this.getOptionValue(optionKey) === undefined) {\n          return false;\n        }\n        return this.getOptionValueSource(optionKey) !== 'default';\n      }\n    );\n\n    const optionsWithConflicting = definedNonDefaultOptions.filter(\n      (option) => option.conflictsWith.length > 0\n    );\n\n    optionsWithConflicting.forEach((option) => {\n      const conflictingAndDefined = definedNonDefaultOptions.find((defined) =>\n        option.conflictsWith.includes(defined.attributeName())\n      );\n      if (conflictingAndDefined) {\n        this._conflictingOption(option, conflictingAndDefined);\n      }\n    });\n  }\n\n  /**\n   * Display an error message if conflicting options are used together.\n   * Called after checking for help flags in leaf subcommand.\n   *\n   * @api private\n   */\n  _checkForConflictingOptions() {\n    // Walk up hierarchy so can call in subcommand after checking for displaying help.\n    for (let cmd = this; cmd; cmd = cmd.parent) {\n      cmd._checkForConflictingLocalOptions();\n    }\n  }\n\n  /**\n   * Parse options from `argv` removing known options,\n   * and return argv split into operands and unknown arguments.\n   *\n   * Examples:\n   *\n   *     argv => operands, unknown\n   *     --known kkk op => [op], []\n   *     op --known kkk => [op], []\n   *     sub --unknown uuu op => [sub], [--unknown uuu op]\n   *     sub -- --unknown uuu op => [sub --unknown uuu op], []\n   *\n   * @param {String[]} argv\n   * @return {{operands: String[], unknown: String[]}}\n   */\n\n  parseOptions(argv) {\n    const operands = []; // operands, not options or values\n    const unknown = []; // first unknown option and remaining unknown args\n    let dest = operands;\n    const args = argv.slice();\n\n    function maybeOption(arg) {\n      return arg.length > 1 && arg[0] === '-';\n    }\n\n    // parse options\n    let activeVariadicOption = null;\n    while (args.length) {\n      const arg = args.shift();\n\n      // literal\n      if (arg === '--') {\n        if (dest === unknown) dest.push(arg);\n        dest.push(...args);\n        break;\n      }\n\n      if (activeVariadicOption && !maybeOption(arg)) {\n        this.emit(`option:${activeVariadicOption.name()}`, arg);\n        continue;\n      }\n      activeVariadicOption = null;\n\n      if (maybeOption(arg)) {\n        const option = this._findOption(arg);\n        // recognised option, call listener to assign value with possible custom processing\n        if (option) {\n          if (option.required) {\n            const value = args.shift();\n            if (value === undefined) this.optionMissingArgument(option);\n            this.emit(`option:${option.name()}`, value);\n          } else if (option.optional) {\n            let value = null;\n            // historical behaviour is optional value is following arg unless an option\n            if (args.length > 0 && !maybeOption(args[0])) {\n              value = args.shift();\n            }\n            this.emit(`option:${option.name()}`, value);\n          } else { // boolean flag\n            this.emit(`option:${option.name()}`);\n          }\n          activeVariadicOption = option.variadic ? option : null;\n          continue;\n        }\n      }\n\n      // Look for combo options following single dash, eat first one if known.\n      if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {\n        const option = this._findOption(`-${arg[1]}`);\n        if (option) {\n          if (option.required || (option.optional && this._combineFlagAndOptionalValue)) {\n            // option with value following in same argument\n            this.emit(`option:${option.name()}`, arg.slice(2));\n          } else {\n            // boolean option, emit and put back remainder of arg for further processing\n            this.emit(`option:${option.name()}`);\n            args.unshift(`-${arg.slice(2)}`);\n          }\n          continue;\n        }\n      }\n\n      // Look for known long flag with value, like --foo=bar\n      if (/^--[^=]+=/.test(arg)) {\n        const index = arg.indexOf('=');\n        const option = this._findOption(arg.slice(0, index));\n        if (option && (option.required || option.optional)) {\n          this.emit(`option:${option.name()}`, arg.slice(index + 1));\n          continue;\n        }\n      }\n\n      // Not a recognised option by this command.\n      // Might be a command-argument, or subcommand option, or unknown option, or help command or option.\n\n      // An unknown option means further arguments also classified as unknown so can be reprocessed by subcommands.\n      if (maybeOption(arg)) {\n        dest = unknown;\n      }\n\n      // If using positionalOptions, stop processing our options at subcommand.\n      if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {\n        if (this._findCommand(arg)) {\n          operands.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {\n          operands.push(arg);\n          if (args.length > 0) operands.push(...args);\n          break;\n        } else if (this._defaultCommandName) {\n          unknown.push(arg);\n          if (args.length > 0) unknown.push(...args);\n          break;\n        }\n      }\n\n      // If using passThroughOptions, stop processing options at first command-argument.\n      if (this._passThroughOptions) {\n        dest.push(arg);\n        if (args.length > 0) dest.push(...args);\n        break;\n      }\n\n      // add arg\n      dest.push(arg);\n    }\n\n    return { operands, unknown };\n  }\n\n  /**\n   * Return an object containing local option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  opts() {\n    if (this._storeOptionsAsProperties) {\n      // Preserve original behaviour so backwards compatible when still using properties\n      const result = {};\n      const len = this.options.length;\n\n      for (let i = 0; i < len; i++) {\n        const key = this.options[i].attributeName();\n        result[key] = key === this._versionOptionName ? this._version : this[key];\n      }\n      return result;\n    }\n\n    return this._optionValues;\n  }\n\n  /**\n   * Return an object containing merged local and global option values as key-value pairs.\n   *\n   * @return {Object}\n   */\n  optsWithGlobals() {\n    // globals overwrite locals\n    return getCommandAndParents(this).reduce(\n      (combinedOptions, cmd) => Object.assign(combinedOptions, cmd.opts()),\n      {}\n    );\n  }\n\n  /**\n   * Display error message and exit (or call exitOverride).\n   *\n   * @param {string} message\n   * @param {Object} [errorOptions]\n   * @param {string} [errorOptions.code] - an id string representing the error\n   * @param {number} [errorOptions.exitCode] - used with process.exit\n   */\n  error(message, errorOptions) {\n    // output handling\n    this._outputConfiguration.outputError(`${message}\\n`, this._outputConfiguration.writeErr);\n    if (typeof this._showHelpAfterError === 'string') {\n      this._outputConfiguration.writeErr(`${this._showHelpAfterError}\\n`);\n    } else if (this._showHelpAfterError) {\n      this._outputConfiguration.writeErr('\\n');\n      this.outputHelp({ error: true });\n    }\n\n    // exit handling\n    const config = errorOptions || {};\n    const exitCode = config.exitCode || 1;\n    const code = config.code || 'commander.error';\n    this._exit(exitCode, code, message);\n  }\n\n  /**\n   * Apply any option related environment variables, if option does\n   * not have a value from cli or client code.\n   *\n   * @api private\n   */\n  _parseOptionsEnv() {\n    this.options.forEach((option) => {\n      if (option.envVar && option.envVar in process.env) {\n        const optionKey = option.attributeName();\n        // Priority check. Do not overwrite cli or options from unknown source (client-code).\n        if (this.getOptionValue(optionKey) === undefined || ['default', 'config', 'env'].includes(this.getOptionValueSource(optionKey))) {\n          if (option.required || option.optional) { // option can take a value\n            // keep very simple, optional always takes value\n            this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);\n          } else { // boolean\n            // keep very simple, only care that envVar defined and not the value\n            this.emit(`optionEnv:${option.name()}`);\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Apply any implied option values, if option is undefined or default value.\n   *\n   * @api private\n   */\n  _parseOptionsImplied() {\n    const dualHelper = new DualOptions(this.options);\n    const hasCustomOptionValue = (optionKey) => {\n      return this.getOptionValue(optionKey) !== undefined && !['default', 'implied'].includes(this.getOptionValueSource(optionKey));\n    };\n    this.options\n      .filter(option => (option.implied !== undefined) &&\n        hasCustomOptionValue(option.attributeName()) &&\n        dualHelper.valueFromOption(this.getOptionValue(option.attributeName()), option))\n      .forEach((option) => {\n        Object.keys(option.implied)\n          .filter(impliedKey => !hasCustomOptionValue(impliedKey))\n          .forEach(impliedKey => {\n            this.setOptionValueWithSource(impliedKey, option.implied[impliedKey], 'implied');\n          });\n      });\n  }\n\n  /**\n   * Argument `name` is missing.\n   *\n   * @param {string} name\n   * @api private\n   */\n\n  missingArgument(name) {\n    const message = `error: missing required argument '${name}'`;\n    this.error(message, { code: 'commander.missingArgument' });\n  }\n\n  /**\n   * `Option` is missing an argument.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  optionMissingArgument(option) {\n    const message = `error: option '${option.flags}' argument missing`;\n    this.error(message, { code: 'commander.optionMissingArgument' });\n  }\n\n  /**\n   * `Option` does not have a value, and is a mandatory option.\n   *\n   * @param {Option} option\n   * @api private\n   */\n\n  missingMandatoryOptionValue(option) {\n    const message = `error: required option '${option.flags}' not specified`;\n    this.error(message, { code: 'commander.missingMandatoryOptionValue' });\n  }\n\n  /**\n   * `Option` conflicts with another option.\n   *\n   * @param {Option} option\n   * @param {Option} conflictingOption\n   * @api private\n   */\n  _conflictingOption(option, conflictingOption) {\n    // The calling code does not know whether a negated option is the source of the\n    // value, so do some work to take an educated guess.\n    const findBestOptionFromValue = (option) => {\n      const optionKey = option.attributeName();\n      const optionValue = this.getOptionValue(optionKey);\n      const negativeOption = this.options.find(target => target.negate && optionKey === target.attributeName());\n      const positiveOption = this.options.find(target => !target.negate && optionKey === target.attributeName());\n      if (negativeOption && (\n        (negativeOption.presetArg === undefined && optionValue === false) ||\n        (negativeOption.presetArg !== undefined && optionValue === negativeOption.presetArg)\n      )) {\n        return negativeOption;\n      }\n      return positiveOption || option;\n    };\n\n    const getErrorMessage = (option) => {\n      const bestOption = findBestOptionFromValue(option);\n      const optionKey = bestOption.attributeName();\n      const source = this.getOptionValueSource(optionKey);\n      if (source === 'env') {\n        return `environment variable '${bestOption.envVar}'`;\n      }\n      return `option '${bestOption.flags}'`;\n    };\n\n    const message = `error: ${getErrorMessage(option)} cannot be used with ${getErrorMessage(conflictingOption)}`;\n    this.error(message, { code: 'commander.conflictingOption' });\n  }\n\n  /**\n   * Unknown option `flag`.\n   *\n   * @param {string} flag\n   * @api private\n   */\n\n  unknownOption(flag) {\n    if (this._allowUnknownOption) return;\n    let suggestion = '';\n\n    if (flag.startsWith('--') && this._showSuggestionAfterError) {\n      // Looping to pick up the global options too\n      let candidateFlags = [];\n      let command = this;\n      do {\n        const moreFlags = command.createHelp().visibleOptions(command)\n          .filter(option => option.long)\n          .map(option => option.long);\n        candidateFlags = candidateFlags.concat(moreFlags);\n        command = command.parent;\n      } while (command && !command._enablePositionalOptions);\n      suggestion = suggestSimilar(flag, candidateFlags);\n    }\n\n    const message = `error: unknown option '${flag}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownOption' });\n  }\n\n  /**\n   * Excess arguments, more than expected.\n   *\n   * @param {string[]} receivedArgs\n   * @api private\n   */\n\n  _excessArguments(receivedArgs) {\n    if (this._allowExcessArguments) return;\n\n    const expected = this._args.length;\n    const s = (expected === 1) ? '' : 's';\n    const forSubcommand = this.parent ? ` for '${this.name()}'` : '';\n    const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;\n    this.error(message, { code: 'commander.excessArguments' });\n  }\n\n  /**\n   * Unknown command.\n   *\n   * @api private\n   */\n\n  unknownCommand() {\n    const unknownName = this.args[0];\n    let suggestion = '';\n\n    if (this._showSuggestionAfterError) {\n      const candidateNames = [];\n      this.createHelp().visibleCommands(this).forEach((command) => {\n        candidateNames.push(command.name());\n        // just visible alias\n        if (command.alias()) candidateNames.push(command.alias());\n      });\n      suggestion = suggestSimilar(unknownName, candidateNames);\n    }\n\n    const message = `error: unknown command '${unknownName}'${suggestion}`;\n    this.error(message, { code: 'commander.unknownCommand' });\n  }\n\n  /**\n   * Set the program version to `str`.\n   *\n   * This method auto-registers the \"-V, --version\" flag\n   * which will print the version number when passed.\n   *\n   * You can optionally supply the  flags and description to override the defaults.\n   *\n   * @param {string} str\n   * @param {string} [flags]\n   * @param {string} [description]\n   * @return {this | string} `this` command for chaining, or version string if no arguments\n   */\n\n  version(str, flags, description) {\n    if (str === undefined) return this._version;\n    this._version = str;\n    flags = flags || '-V, --version';\n    description = description || 'output the version number';\n    const versionOption = this.createOption(flags, description);\n    this._versionOptionName = versionOption.attributeName();\n    this.options.push(versionOption);\n    this.on('option:' + versionOption.name(), () => {\n      this._outputConfiguration.writeOut(`${str}\\n`);\n      this._exit(0, 'commander.version', str);\n    });\n    return this;\n  }\n\n  /**\n   * Set the description.\n   *\n   * @param {string} [str]\n   * @param {Object} [argsDescription]\n   * @return {string|Command}\n   */\n  description(str, argsDescription) {\n    if (str === undefined && argsDescription === undefined) return this._description;\n    this._description = str;\n    if (argsDescription) {\n      this._argsDescription = argsDescription;\n    }\n    return this;\n  }\n\n  /**\n   * Set the summary. Used when listed as subcommand of parent.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n  summary(str) {\n    if (str === undefined) return this._summary;\n    this._summary = str;\n    return this;\n  }\n\n  /**\n   * Set an alias for the command.\n   *\n   * You may call more than once to add multiple aliases. Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string} [alias]\n   * @return {string|Command}\n   */\n\n  alias(alias) {\n    if (alias === undefined) return this._aliases[0]; // just return first, for backwards compatibility\n\n    /** @type {Command} */\n    let command = this;\n    if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {\n      // assume adding alias for last added executable subcommand, rather than this\n      command = this.commands[this.commands.length - 1];\n    }\n\n    if (alias === command._name) throw new Error('Command alias can\\'t be the same as its name');\n\n    command._aliases.push(alias);\n    return this;\n  }\n\n  /**\n   * Set aliases for the command.\n   *\n   * Only the first alias is shown in the auto-generated help.\n   *\n   * @param {string[]} [aliases]\n   * @return {string[]|Command}\n   */\n\n  aliases(aliases) {\n    // Getter for the array of aliases is the main reason for having aliases() in addition to alias().\n    if (aliases === undefined) return this._aliases;\n\n    aliases.forEach((alias) => this.alias(alias));\n    return this;\n  }\n\n  /**\n   * Set / get the command usage `str`.\n   *\n   * @param {string} [str]\n   * @return {String|Command}\n   */\n\n  usage(str) {\n    if (str === undefined) {\n      if (this._usage) return this._usage;\n\n      const args = this._args.map((arg) => {\n        return humanReadableArgName(arg);\n      });\n      return [].concat(\n        (this.options.length || this._hasHelpOption ? '[options]' : []),\n        (this.commands.length ? '[command]' : []),\n        (this._args.length ? args : [])\n      ).join(' ');\n    }\n\n    this._usage = str;\n    return this;\n  }\n\n  /**\n   * Get or set the name of the command.\n   *\n   * @param {string} [str]\n   * @return {string|Command}\n   */\n\n  name(str) {\n    if (str === undefined) return this._name;\n    this._name = str;\n    return this;\n  }\n\n  /**\n   * Set the name of the command from script filename, such as process.argv[1],\n   * or require.main.filename, or __filename.\n   *\n   * (Used internally and public although not documented in README.)\n   *\n   * @example\n   * program.nameFromFilename(require.main.filename);\n   *\n   * @param {string} filename\n   * @return {Command}\n   */\n\n  nameFromFilename(filename) {\n    this._name = path.basename(filename, path.extname(filename));\n\n    return this;\n  }\n\n  /**\n   * Get or set the directory for searching for executable subcommands of this command.\n   *\n   * @example\n   * program.executableDir(__dirname);\n   * // or\n   * program.executableDir('subcommands');\n   *\n   * @param {string} [path]\n   * @return {string|Command}\n   */\n\n  executableDir(path) {\n    if (path === undefined) return this._executableDir;\n    this._executableDir = path;\n    return this;\n  }\n\n  /**\n   * Return program help documentation.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to wrap for stderr instead of stdout\n   * @return {string}\n   */\n\n  helpInformation(contextOptions) {\n    const helper = this.createHelp();\n    if (helper.helpWidth === undefined) {\n      helper.helpWidth = (contextOptions && contextOptions.error) ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();\n    }\n    return helper.formatHelp(this, helper);\n  }\n\n  /**\n   * @api private\n   */\n\n  _getHelpContext(contextOptions) {\n    contextOptions = contextOptions || {};\n    const context = { error: !!contextOptions.error };\n    let write;\n    if (context.error) {\n      write = (arg) => this._outputConfiguration.writeErr(arg);\n    } else {\n      write = (arg) => this._outputConfiguration.writeOut(arg);\n    }\n    context.write = contextOptions.write || write;\n    context.command = this;\n    return context;\n  }\n\n  /**\n   * Output help information for this command.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean } | Function} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  outputHelp(contextOptions) {\n    let deprecatedCallback;\n    if (typeof contextOptions === 'function') {\n      deprecatedCallback = contextOptions;\n      contextOptions = undefined;\n    }\n    const context = this._getHelpContext(contextOptions);\n\n    getCommandAndParents(this).reverse().forEach(command => command.emit('beforeAllHelp', context));\n    this.emit('beforeHelp', context);\n\n    let helpInformation = this.helpInformation(context);\n    if (deprecatedCallback) {\n      helpInformation = deprecatedCallback(helpInformation);\n      if (typeof helpInformation !== 'string' && !Buffer.isBuffer(helpInformation)) {\n        throw new Error('outputHelp callback must return a string or a Buffer');\n      }\n    }\n    context.write(helpInformation);\n\n    this.emit(this._helpLongFlag); // deprecated\n    this.emit('afterHelp', context);\n    getCommandAndParents(this).forEach(command => command.emit('afterAllHelp', context));\n  }\n\n  /**\n   * You can pass in flags and a description to override the help\n   * flags and help description for your command. Pass in false to\n   * disable the built-in help option.\n   *\n   * @param {string | boolean} [flags]\n   * @param {string} [description]\n   * @return {Command} `this` command for chaining\n   */\n\n  helpOption(flags, description) {\n    if (typeof flags === 'boolean') {\n      this._hasHelpOption = flags;\n      return this;\n    }\n    this._helpFlags = flags || this._helpFlags;\n    this._helpDescription = description || this._helpDescription;\n\n    const helpFlags = splitOptionFlags(this._helpFlags);\n    this._helpShortFlag = helpFlags.shortFlag;\n    this._helpLongFlag = helpFlags.longFlag;\n\n    return this;\n  }\n\n  /**\n   * Output help information and exit.\n   *\n   * Outputs built-in help, and custom text added using `.addHelpText()`.\n   *\n   * @param {{ error: boolean }} [contextOptions] - pass {error:true} to write to stderr instead of stdout\n   */\n\n  help(contextOptions) {\n    this.outputHelp(contextOptions);\n    let exitCode = process.exitCode || 0;\n    if (exitCode === 0 && contextOptions && typeof contextOptions !== 'function' && contextOptions.error) {\n      exitCode = 1;\n    }\n    // message: do not have all displayed text available so only passing placeholder.\n    this._exit(exitCode, 'commander.help', '(outputHelp)');\n  }\n\n  /**\n   * Add additional text to be displayed with the built-in help.\n   *\n   * Position is 'before' or 'after' to affect just this command,\n   * and 'beforeAll' or 'afterAll' to affect this command and all its subcommands.\n   *\n   * @param {string} position - before or after built-in help\n   * @param {string | Function} text - string to add, or a function returning a string\n   * @return {Command} `this` command for chaining\n   */\n  addHelpText(position, text) {\n    const allowedValues = ['beforeAll', 'before', 'after', 'afterAll'];\n    if (!allowedValues.includes(position)) {\n      throw new Error(`Unexpected value for position to addHelpText.\nExpecting one of '${allowedValues.join(\"', '\")}'`);\n    }\n    const helpEvent = `${position}Help`;\n    this.on(helpEvent, (context) => {\n      let helpStr;\n      if (typeof text === 'function') {\n        helpStr = text({ error: context.error, command: context.command });\n      } else {\n        helpStr = text;\n      }\n      // Ignore falsy value when nothing to output.\n      if (helpStr) {\n        context.write(`${helpStr}\\n`);\n      }\n    });\n    return this;\n  }\n}\n\n/**\n * Output help information if help flags specified\n *\n * @param {Command} cmd - command to output help for\n * @param {Array} args - array of options to search for help flags\n * @api private\n */\n\nfunction outputHelpIfRequested(cmd, args) {\n  const helpOption = cmd._hasHelpOption && args.find(arg => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);\n  if (helpOption) {\n    cmd.outputHelp();\n    // (Do not have all displayed text available so only passing placeholder.)\n    cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');\n  }\n}\n\n/**\n * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @api private\n */\n\nfunction incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }\n    let debugOption;\n    let debugHost = '127.0.0.1';\n    let debugPort = '9229';\n    let match;\n    if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {\n      // e.g. --inspect\n      debugOption = match[1];\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {\n      debugOption = match[1];\n      if (/^\\d+$/.test(match[3])) {\n        // e.g. --inspect=1234\n        debugPort = match[3];\n      } else {\n        // e.g. --inspect=localhost\n        debugHost = match[3];\n      }\n    } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\\d+)$/)) !== null) {\n      // e.g. --inspect=localhost:1234\n      debugOption = match[1];\n      debugHost = match[3];\n      debugPort = match[4];\n    }\n\n    if (debugOption && debugPort !== '0') {\n      return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;\n    }\n    return arg;\n  });\n}\n\n/**\n * @param {Command} startCommand\n * @returns {Command[]}\n * @api private\n */\n\nfunction getCommandAndParents(startCommand) {\n  const result = [];\n  for (let command = startCommand; command; command = command.parent) {\n    result.push(command);\n  }\n  return result;\n}\n\nexports.Command = Command;\n","const { Argument } = require('./lib/argument.js');\nconst { Command } = require('./lib/command.js');\nconst { CommanderError, InvalidArgumentError } = require('./lib/error.js');\nconst { Help } = require('./lib/help.js');\nconst { Option } = require('./lib/option.js');\n\n// @ts-check\n\n/**\n * Expose the root command.\n */\n\nexports = module.exports = new Command();\nexports.program = exports; // More explicit access to global command.\n// Implicit export of createArgument, createCommand, and createOption.\n\n/**\n * Expose classes\n */\n\nexports.Argument = Argument;\nexports.Command = Command;\nexports.CommanderError = CommanderError;\nexports.Help = Help;\nexports.InvalidArgumentError = InvalidArgumentError;\nexports.InvalidOptionArgumentError = InvalidArgumentError; // Deprecated\nexports.Option = Option;\n","import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Cli } from './cli';\r\nimport { Primary } from './primary';\r\nimport { Queue } from './queue';\r\n\r\nexport class Cluster {\r\n  commands: CliDefinition[];\r\n  useLogging: boolean;\r\n  onPrimaryMessage: (\r\n    worker: typeof cluster.worker,\r\n    message: any\r\n  ) => Promise<void>;\r\n  onWorkerMessage: (message: any) => Promise<void>;\r\n\r\n  constructor(commands: CliDefinition[], useLogging: boolean = false) {\r\n    this.commands = commands;\r\n    this.useLogging = useLogging;\r\n\r\n    // Default actions\r\n    this.commands.push({\r\n      command: 'log',\r\n      action: console.log,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cluster node message handlers\r\n   */\r\n  onMessage(\r\n    onPrimaryMessage: (\r\n      worker: typeof cluster.worker,\r\n      message: any\r\n    ) => Promise<void>,\r\n    onWorkerMessage: (message: any) => Promise<void>\r\n  ) {\r\n    this.onPrimaryMessage = onPrimaryMessage;\r\n    this.onWorkerMessage = onWorkerMessage;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Start the cluster nodes\r\n   */\r\n  async start(\r\n    onPrimaryStart: (primary: Primary) => Promise<void>,\r\n    onWorkerStart: (worker: typeof cluster.worker) => Promise<void>\r\n  ) {\r\n    if (cluster.isPrimary) {\r\n      const primaryQueue = new Queue(cluster);\r\n      const workerQueue = new Queue(cluster);\r\n      const cli = new Cli(primaryQueue, this.commands);\r\n      const primary = new Primary(\r\n        cluster,\r\n        cli,\r\n        primaryQueue,\r\n        workerQueue,\r\n        this.onPrimaryMessage,\r\n        this.onWorkerMessage,\r\n        this.useLogging\r\n      );\r\n\r\n      // Parse the CLI\r\n      cli.start();\r\n\r\n      // Wait for the primary queue to be empty\r\n\r\n      await primary.start();\r\n      await onPrimaryStart(primary);\r\n    } else {\r\n      await onWorkerStart(cluster.worker);\r\n    }\r\n  }\r\n}\r\n\r\n// @TODO: build a test bench\r\n\r\n(async function main() {\r\n  const instance = new Cluster(\r\n    [\r\n      {\r\n        command: 'cli:setState',\r\n        description: 'Sets a state in the primary process',\r\n        args: {\r\n          '<text>': 'The name of the state to set',\r\n        },\r\n        options: {},\r\n        action: (args: KeyPair, state: KeyPair) => {\r\n          state.text = args.cli.text;\r\n        },\r\n      },\r\n    ],\r\n    true\r\n  ).onMessage(\r\n    async (worker: typeof cluster.worker, message: any) => {\r\n      console.log('PRIMARY MESSAGE');\r\n    },\r\n    async (message: any) => {\r\n      console.log('WORKER MESSAGE');\r\n    }\r\n  );\r\n\r\n  await instance.start(\r\n    async () => {\r\n      console.log('PRIMARY START');\r\n    },\r\n    async () => {\r\n      console.log('WORKER START');\r\n    }\r\n  );\r\n})();\r\n","import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command as Commander } from 'commander';\r\nimport { Queue } from './queue';\r\nimport { Command } from './command';\r\n\r\nconst { name, description, version } = require('../package.json');\r\n\r\nconst removeChars = /[^A-Za-z0-9_]/g;\r\n\r\nexport class Cli {\r\n  queue: Queue;\r\n  program: Commander;\r\n\r\n  constructor(queue: Queue, definitions: CliDefinition[]) {\r\n    this.queue = queue;\r\n    this.program = new Commander();\r\n    this.program.name(name).description(description).version(version);\r\n\r\n    for (const definition of definitions) {\r\n      this.register(definition);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a new CLI command\r\n   */\r\n  register(definition: CliDefinition) {\r\n    if (!cluster.isPrimary) {\r\n      return;\r\n    }\r\n\r\n    const isCliCommand = definition.command.indexOf('cli:') === 0;\r\n\r\n    const commandName = isCliCommand\r\n      ? definition.command.substring(4)\r\n      : definition.command;\r\n\r\n    // Register the definition as a command\r\n    Command.register(definition.command, definition.action);\r\n\r\n    if (!isCliCommand) {\r\n      return;\r\n    }\r\n\r\n    // Register the command\r\n    const newCommand =\r\n      commandName === '' ? this.program : this.program.command(commandName);\r\n\r\n    newCommand.description(definition.description);\r\n\r\n    // Define the end-of-line arguments\r\n    const argKeys = Object.keys(definition.args);\r\n\r\n    for (const arg of argKeys) {\r\n      const description = definition.args[arg];\r\n\r\n      newCommand.argument(arg, description);\r\n    }\r\n\r\n    // Define the flags/options\r\n    for (const option of Object.keys(definition.options)) {\r\n      const description = definition.options[option];\r\n\r\n      newCommand.option(option, description);\r\n    }\r\n\r\n    // program.action(definition.action);\r\n    newCommand.action((...args: string[] & [(KeyPair | string)?]) => {\r\n      const options =\r\n        typeof args[args.length - 2] === 'string'\r\n          ? {}\r\n          : (args[args.length - 2] as KeyPair);\r\n\r\n      options.cli = {};\r\n\r\n      let i = 0;\r\n      for (const key of argKeys) {\r\n        options.cli[key.replace(removeChars, '')] = args[i];\r\n        i += 1;\r\n      }\r\n\r\n      this.queue.add(\r\n        new Command(definition.command, options, 'cli', 'primary')\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start the CLI\r\n   */\r\n  start() {\r\n    this.program.parse(process.argv);\r\n  }\r\n}\r\n","import commander from './index.js';\n\n// wrapper to provide named exports for ESM.\nexport const {\n  program,\n  createCommand,\n  createArgument,\n  createOption,\n  CommanderError,\n  InvalidArgumentError,\n  Command,\n  Argument,\n  Option,\n  Help\n} = commander;\n","import type {\r\n  CommandAction,\r\n  CommandFrom,\r\n  CommandTo,\r\n  iCommand,\r\n  KeyPair,\r\n} from './index.d';\r\nimport { Queue } from './queue';\r\n\r\nconst commands: KeyPair<CommandAction> = {};\r\n\r\nexport class Command implements iCommand {\r\n  command: string;\r\n  args: KeyPair;\r\n  from: CommandFrom;\r\n  to: CommandTo;\r\n\r\n  /**\r\n   * Registers a new command\r\n   */\r\n  static register(command: string, onAction: CommandAction) {\r\n    commands[command] = onAction;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  constructor(\r\n    command: string,\r\n    args: KeyPair,\r\n    from: CommandFrom,\r\n    to: CommandTo\r\n  ) {\r\n    if (commands[command] === undefined) {\r\n      throw new RangeError(`\"${command}\" has not been registered.`);\r\n    }\r\n\r\n    this.command = command;\r\n    this.args = args;\r\n    this.from = from;\r\n    this.to = to;\r\n  }\r\n\r\n  /**\r\n   * Clones a command and changes the to and from properties\r\n   */\r\n  clone(from: CommandFrom, to: CommandTo) {\r\n    return new Command(this.command, this.args, from, to);\r\n  }\r\n\r\n  /**\r\n   * Runs the command\r\n   */\r\n  run(state: KeyPair, priamryQueue: Queue, workerQueue: Queue) {\r\n    return commands[this.command](\r\n      this.args,\r\n      state,\r\n      this,\r\n      priamryQueue,\r\n      workerQueue\r\n    );\r\n  }\r\n}\r\n","import type { KeyPair } from './index.d';\r\ntype Process = typeof cluster;\r\n\r\nimport cluster from 'cluster';\r\nimport * as os from 'os';\r\nimport { Cli } from './cli';\r\nimport { Command } from './command';\r\nimport { Queue } from './queue';\r\nimport { Worker } from './worker';\r\n\r\nconst cpus = os.cpus();\r\nconst numWorkers = cpus.length;\r\n\r\nexport class Primary {\r\n  process: Process;\r\n  workers: Worker[] = [];\r\n  primaryQueue: Queue;\r\n  workerQueue: Queue;\r\n  useLogging: boolean;\r\n  cli: Cli;\r\n  state: KeyPair = {};\r\n\r\n  constructor(\r\n    process: Process,\r\n    cli: Cli,\r\n    primaryQueue: Queue,\r\n    workerQueue: Queue,\r\n    onPrimaryMessage: (\r\n      worker: typeof cluster.worker,\r\n      command: Command\r\n    ) => Promise<void>,\r\n    onWorkerMessage: (message: any) => Promise<void>,\r\n    useLogging: boolean = false\r\n  ) {\r\n    this.cli = cli;\r\n    this.process = process;\r\n    this.useLogging = useLogging;\r\n    this.primaryQueue = primaryQueue;\r\n    this.workerQueue = workerQueue;\r\n\r\n    process.on('newCommand', (to: string) => {\r\n      // New command enqueued\r\n      if (to === 'primary') {\r\n        // Primary should run its next command\r\n        const command = this.primaryQueue.next();\r\n        command.run(this.state, this.primaryQueue, this.workerQueue);\r\n      } else {\r\n        // All workers should be told a new command has appeared\r\n        this.send(new Command('_pending', {}, 'primary', 'workers'))\r\n      }\r\n    });\r\n\r\n    process.on('message', async (worker, command) => {\r\n      // Primary receives message from worker\r\n      console.log('WAT');\r\n      if (command.command === '_next') {\r\n        const nextCommand = this.workerQueue.next(worker);\r\n        await onPrimaryMessage(worker, nextCommand);\r\n      } else {\r\n        await onPrimaryMessage(worker, command);\r\n      }\r\n    });\r\n\r\n    process.on('exit', (worker, code, signal) => {\r\n      // When a worker quits\r\n      if (this.useLogging) {\r\n        console.info(\r\n          'Worker ' +\r\n            worker.process.pid +\r\n            ' died with code: ' +\r\n            code +\r\n            ', and signal: ' +\r\n            signal\r\n        );\r\n      }\r\n\r\n      this.spawnWorker();\r\n    });\r\n\r\n    process.on('online', (worker) => {\r\n      // When a worker spawns\r\n      if (this.useLogging) {\r\n        console.info('Worker ' + worker.process.pid + ' is online');\r\n      }\r\n\r\n      const newWorker = new Worker(worker, onWorkerMessage);\r\n      this.workers.push(newWorker);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Starts the priamry process\r\n   */\r\n  async start() {\r\n    await Promise.all([\r\n      new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          if (this.primaryQueue.queue.length === 0) {\r\n            resolve(true);\r\n          }\r\n        }, 100);\r\n      }),\r\n    ]);\r\n\r\n    if (this.useLogging) {\r\n      console.info('Primary cluster setting up ' + numWorkers + ' workers...');\r\n    }\r\n\r\n    for (var i = 0; i < numWorkers; i++) {\r\n      this.spawnWorker();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn a new worker that self-cleans up\r\n   */\r\n  spawnWorker() {\r\n    let worker = this.process.fork();\r\n\r\n    worker.on('disconnect', () => {\r\n      worker.removeAllListeners();\r\n      worker.kill();\r\n      worker = undefined;\r\n    });\r\n\r\n    return worker;\r\n  }\r\n\r\n  /**\r\n   * Adds a command for later processing\r\n   */\r\n  addTask(command: Command): Command {\r\n    if (command.to === 'primary') {\r\n      this.primaryQueue.add(command);\r\n    } else {\r\n      this.workerQueue.add(command);\r\n    }\r\n\r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  workerCommand(command: string, args: KeyPair) {\r\n    this.addTask(new Command(command, args, 'primary', 'workers'))\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  primaryCommand(command: string, args: KeyPair) {\r\n    this.addTask(new Command(command, args, 'primary', 'primary'))\r\n  }\r\n\r\n  /**\r\n   * Get worker processes\r\n   */\r\n  getWorkerProcesses() {\r\n    return Object.values(cluster.workers);\r\n  }\r\n\r\n  /**\r\n   * Restart all Worker instances\r\n   */\r\n  restartWorkers() {\r\n    for (const worker of this.workers) {\r\n      worker.restart();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message to workers\r\n   */\r\n  send(command: Command) {\r\n    const workers = this.getWorkerProcesses();\r\n\r\n    for (const worker of workers) {\r\n      if (\r\n        command.to === 'workers' ||\r\n        (worker.process !== undefined && worker.process.pid === command.to)\r\n      ) {\r\n        if (this.useLogging) {\r\n          console.info(`[PRIMARY -> PID ${worker.process.pid}]`, command);\r\n        }\r\n\r\n        worker.process.send(command);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { KeyPair } from './index.d';\r\ntype Process = typeof cluster.worker;\r\n\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\nexport class Worker {\r\n  process: Process;\r\n\r\n  constructor(worker: Process, onMessage: (message: any) => Promise<void>) {\r\n    this.process = worker;\r\n\r\n    this.process.on('message', async (message) => {\r\n      if (this.process.process !== undefined) {\r\n        console.info(`[PRIMARY -> PID ${this.process.process.pid}]`, message);\r\n        await onMessage(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restarts the worker\r\n   */\r\n  restart() {\r\n    this.primaryCommand('shutdown');\r\n\r\n    this.kill();\r\n  }\r\n\r\n  /**\r\n   * Kills the worker\r\n   */\r\n  kill() {\r\n    this.process.removeAllListeners();\r\n    this.process.kill('SIGKILL');\r\n    this.process = undefined;\r\n  }\r\n\r\n  /**\r\n   * Sends a message from the worker to the primary\r\n   */\r\n  send(command: Command) {\r\n    console.info(`[PID ${this.process.process.pid} -> PRIMARY]`, command);\r\n    this.process.process.send(command);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  workerCommand(command: string, args: KeyPair = {}) {\r\n    this.send(new Command(command, args, this.process.process.pid, 'workers'));\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  primaryCommand(command: string, args: KeyPair = {}) {\r\n    this.send(new Command(command, args, this.process.process.pid, 'primary'));\r\n  }\r\n}\r\n","import type { iQueue } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\ntype Priamry = typeof cluster;\r\ntype Worker = typeof cluster.worker;\r\n\r\nexport class Queue implements iQueue {\r\n  queue: Command[] = [];\r\n  primary: Priamry;\r\n\r\n  constructor(primary: Priamry) {\r\n    this.primary = primary;\r\n  }\r\n\r\n  /**\r\n   * Adds a command to the queue\r\n   */\r\n  add(command: Command) {\r\n    const index = this.queue.push(command);\r\n    this.primary.emit('newCommand', command.to);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Removes the first command from the queue\r\n   */\r\n  shift() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  /**\r\n   * Gets the first command in the queue and may send it to the worker to do\r\n   */\r\n  next(worker?: Worker): Command | undefined {\r\n    const command = this.queue.shift();\r\n\r\n    if (command === undefined) {\r\n      return;\r\n    }\r\n\r\n    const pid = cluster.isPrimary ? 'primary' : worker.process.pid;\r\n    const newCommand = command.clone('primary', pid);\r\n\r\n    if (worker) {\r\n      worker.send(newCommand);\r\n    }\r\n\r\n    return newCommand;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}