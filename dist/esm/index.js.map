{"version":3,"sources":["../../src/index.ts","../../src/cli.ts","../../src/command.ts","../../src/primary.ts","../../src/worker.ts","../../src/queue.ts"],"sourcesContent":["import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Cli } from './cli';\r\nimport { Primary } from './primary';\r\nimport { Queue } from './queue';\r\n\r\nexport class Cluster {\r\n  commands: CliDefinition[];\r\n  useLogging: boolean;\r\n  onPrimaryMessage: (\r\n    worker: typeof cluster.worker,\r\n    message: any\r\n  ) => Promise<void>;\r\n  onWorkerMessage: (message: any) => Promise<void>;\r\n\r\n  constructor(commands: CliDefinition[], useLogging: boolean = false) {\r\n    this.commands = commands;\r\n    this.useLogging = useLogging;\r\n\r\n    // Default actions\r\n    this.commands.push({\r\n      command: 'log',\r\n      action: console.log,\r\n    });\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cluster node message handlers\r\n   */\r\n  onMessage(\r\n    onPrimaryMessage: (\r\n      worker: typeof cluster.worker,\r\n      message: any\r\n    ) => Promise<void>,\r\n    onWorkerMessage: (message: any) => Promise<void>\r\n  ) {\r\n    this.onPrimaryMessage = onPrimaryMessage;\r\n    this.onWorkerMessage = onWorkerMessage;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Start the cluster nodes\r\n   */\r\n  async start(\r\n    onPrimaryStart: (primary: Primary) => Promise<void>,\r\n    onWorkerStart: (worker: typeof cluster.worker) => Promise<void>\r\n  ) {\r\n    if (cluster.isPrimary) {\r\n      const primaryQueue = new Queue(cluster);\r\n      const workerQueue = new Queue(cluster);\r\n      const cli = new Cli(primaryQueue, this.commands);\r\n      const primary = new Primary(\r\n        cluster,\r\n        cli,\r\n        primaryQueue,\r\n        workerQueue,\r\n        this.onPrimaryMessage,\r\n        this.onWorkerMessage,\r\n        this.useLogging\r\n      );\r\n\r\n      // Parse the CLI\r\n      cli.start();\r\n\r\n      // Wait for the primary queue to be empty\r\n\r\n      await primary.start();\r\n      await onPrimaryStart(primary);\r\n    } else {\r\n      await onWorkerStart(cluster.worker);\r\n    }\r\n  }\r\n}\r\n\r\n// @TODO: build a test bench\r\n\r\n(async function main() {\r\n  const instance = new Cluster(\r\n    [\r\n      {\r\n        command: 'cli:setState',\r\n        description: 'Sets a state in the primary process',\r\n        args: {\r\n          '<text>': 'The name of the state to set',\r\n        },\r\n        options: {},\r\n        action: (args: KeyPair, state: KeyPair) => {\r\n          state.text = args.cli.text;\r\n        },\r\n      },\r\n    ],\r\n    true\r\n  ).onMessage(\r\n    async (worker: typeof cluster.worker, message: any) => {\r\n      console.log('PRIMARY MESSAGE');\r\n    },\r\n    async (message: any) => {\r\n      console.log('WORKER MESSAGE');\r\n    }\r\n  );\r\n\r\n  await instance.start(\r\n    async () => {\r\n      console.log('PRIMARY START');\r\n    },\r\n    async () => {\r\n      console.log('WORKER START');\r\n    }\r\n  );\r\n})();\r\n","import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command as Commander } from 'commander';\r\nimport { Queue } from './queue';\r\nimport { Command } from './command';\r\n\r\nconst { name, description, version } = require('../package.json');\r\n\r\nconst removeChars = /[^A-Za-z0-9_]/g;\r\n\r\nexport class Cli {\r\n  queue: Queue;\r\n  program: Commander;\r\n\r\n  constructor(queue: Queue, definitions: CliDefinition[]) {\r\n    this.queue = queue;\r\n    this.program = new Commander();\r\n    this.program.name(name).description(description).version(version);\r\n\r\n    for (const definition of definitions) {\r\n      this.register(definition);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a new CLI command\r\n   */\r\n  register(definition: CliDefinition) {\r\n    if (!cluster.isPrimary) {\r\n      return;\r\n    }\r\n\r\n    const isCliCommand = definition.command.indexOf('cli:') === 0;\r\n\r\n    const commandName = isCliCommand\r\n      ? definition.command.substring(4)\r\n      : definition.command;\r\n\r\n    // Register the definition as a command\r\n    Command.register(definition.command, definition.action);\r\n\r\n    if (!isCliCommand) {\r\n      return;\r\n    }\r\n\r\n    // Register the command\r\n    const newCommand =\r\n      commandName === '' ? this.program : this.program.command(commandName);\r\n\r\n    newCommand.description(definition.description);\r\n\r\n    // Define the end-of-line arguments\r\n    const argKeys = Object.keys(definition.args);\r\n\r\n    for (const arg of argKeys) {\r\n      const description = definition.args[arg];\r\n\r\n      newCommand.argument(arg, description);\r\n    }\r\n\r\n    // Define the flags/options\r\n    for (const option of Object.keys(definition.options)) {\r\n      const description = definition.options[option];\r\n\r\n      newCommand.option(option, description);\r\n    }\r\n\r\n    // program.action(definition.action);\r\n    newCommand.action((...args: string[] & [(KeyPair | string)?]) => {\r\n      const options =\r\n        typeof args[args.length - 2] === 'string'\r\n          ? {}\r\n          : (args[args.length - 2] as KeyPair);\r\n\r\n      options.cli = {};\r\n\r\n      let i = 0;\r\n      for (const key of argKeys) {\r\n        options.cli[key.replace(removeChars, '')] = args[i];\r\n        i += 1;\r\n      }\r\n\r\n      this.queue.add(\r\n        new Command(definition.command, options, 'cli', 'primary')\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start the CLI\r\n   */\r\n  start() {\r\n    this.program.parse(process.argv);\r\n  }\r\n}\r\n","import type {\r\n  CommandAction,\r\n  CommandFrom,\r\n  CommandTo,\r\n  iCommand,\r\n  KeyPair,\r\n} from './index.d';\r\nimport { Queue } from './queue';\r\n\r\nconst commands: KeyPair<CommandAction> = {};\r\n\r\nexport class Command implements iCommand {\r\n  command: string;\r\n  args: KeyPair;\r\n  from: CommandFrom;\r\n  to: CommandTo;\r\n\r\n  /**\r\n   * Registers a new command\r\n   */\r\n  static register(command: string, onAction: CommandAction) {\r\n    commands[command] = onAction;\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  constructor(\r\n    command: string,\r\n    args: KeyPair,\r\n    from: CommandFrom,\r\n    to: CommandTo\r\n  ) {\r\n    if (commands[command] === undefined) {\r\n      throw new RangeError(`\"${command}\" has not been registered.`);\r\n    }\r\n\r\n    this.command = command;\r\n    this.args = args;\r\n    this.from = from;\r\n    this.to = to;\r\n  }\r\n\r\n  /**\r\n   * Clones a command and changes the to and from properties\r\n   */\r\n  clone(from: CommandFrom, to: CommandTo) {\r\n    return new Command(this.command, this.args, from, to);\r\n  }\r\n\r\n  /**\r\n   * Runs the command\r\n   */\r\n  run(state: KeyPair, priamryQueue: Queue, workerQueue: Queue) {\r\n    return commands[this.command](\r\n      this.args,\r\n      state,\r\n      this,\r\n      priamryQueue,\r\n      workerQueue\r\n    );\r\n  }\r\n}\r\n","import type { KeyPair } from './index.d';\r\ntype Process = typeof cluster;\r\n\r\nimport cluster from 'cluster';\r\nimport * as os from 'os';\r\nimport { Cli } from './cli';\r\nimport { Command } from './command';\r\nimport { Queue } from './queue';\r\nimport { Worker } from './worker';\r\n\r\nconst cpus = os.cpus();\r\nconst numWorkers = cpus.length;\r\n\r\nexport class Primary {\r\n  process: Process;\r\n  workers: Worker[] = [];\r\n  primaryQueue: Queue;\r\n  workerQueue: Queue;\r\n  useLogging: boolean;\r\n  cli: Cli;\r\n  state: KeyPair = {};\r\n\r\n  constructor(\r\n    process: Process,\r\n    cli: Cli,\r\n    primaryQueue: Queue,\r\n    workerQueue: Queue,\r\n    onPrimaryMessage: (\r\n      worker: typeof cluster.worker,\r\n      command: Command\r\n    ) => Promise<void>,\r\n    onWorkerMessage: (message: any) => Promise<void>,\r\n    useLogging: boolean = false\r\n  ) {\r\n    this.cli = cli;\r\n    this.process = process;\r\n    this.useLogging = useLogging;\r\n    this.primaryQueue = primaryQueue;\r\n    this.workerQueue = workerQueue;\r\n\r\n    process.on('newCommand', (to: string) => {\r\n      // New command enqueued\r\n      if (to === 'primary') {\r\n        // Primary should run its next command\r\n        const command = this.primaryQueue.next();\r\n        command.run(this.state, this.primaryQueue, this.workerQueue);\r\n      } else {\r\n        // All workers should be told a new command has appeared\r\n        this.send(new Command('_pending', {}, 'primary', 'workers'))\r\n      }\r\n    });\r\n\r\n    process.on('message', async (worker, command) => {\r\n      // Primary receives message from worker\r\n      console.log('WAT');\r\n      if (command.command === '_next') {\r\n        const nextCommand = this.workerQueue.next(worker);\r\n        await onPrimaryMessage(worker, nextCommand);\r\n      } else {\r\n        await onPrimaryMessage(worker, command);\r\n      }\r\n    });\r\n\r\n    process.on('exit', (worker, code, signal) => {\r\n      // When a worker quits\r\n      if (this.useLogging) {\r\n        console.info(\r\n          'Worker ' +\r\n            worker.process.pid +\r\n            ' died with code: ' +\r\n            code +\r\n            ', and signal: ' +\r\n            signal\r\n        );\r\n      }\r\n\r\n      this.spawnWorker();\r\n    });\r\n\r\n    process.on('online', (worker) => {\r\n      // When a worker spawns\r\n      if (this.useLogging) {\r\n        console.info('Worker ' + worker.process.pid + ' is online');\r\n      }\r\n\r\n      const newWorker = new Worker(worker, onWorkerMessage);\r\n      this.workers.push(newWorker);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Starts the priamry process\r\n   */\r\n  async start() {\r\n    await Promise.all([\r\n      new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          if (this.primaryQueue.queue.length === 0) {\r\n            resolve(true);\r\n          }\r\n        }, 100);\r\n      }),\r\n    ]);\r\n\r\n    if (this.useLogging) {\r\n      console.info('Primary cluster setting up ' + numWorkers + ' workers...');\r\n    }\r\n\r\n    for (var i = 0; i < numWorkers; i++) {\r\n      this.spawnWorker();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn a new worker that self-cleans up\r\n   */\r\n  spawnWorker() {\r\n    let worker = this.process.fork();\r\n\r\n    worker.on('disconnect', () => {\r\n      worker.removeAllListeners();\r\n      worker.kill();\r\n      worker = undefined;\r\n    });\r\n\r\n    return worker;\r\n  }\r\n\r\n  /**\r\n   * Adds a command for later processing\r\n   */\r\n  addTask(command: Command): Command {\r\n    if (command.to === 'primary') {\r\n      this.primaryQueue.add(command);\r\n    } else {\r\n      this.workerQueue.add(command);\r\n    }\r\n\r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  workerCommand(command: string, args: KeyPair) {\r\n    this.addTask(new Command(command, args, 'primary', 'workers'))\r\n  }\r\n\r\n  /**\r\n   * \r\n   */\r\n  primaryCommand(command: string, args: KeyPair) {\r\n    this.addTask(new Command(command, args, 'primary', 'primary'))\r\n  }\r\n\r\n  /**\r\n   * Get worker processes\r\n   */\r\n  getWorkerProcesses() {\r\n    return Object.values(cluster.workers);\r\n  }\r\n\r\n  /**\r\n   * Restart all Worker instances\r\n   */\r\n  restartWorkers() {\r\n    for (const worker of this.workers) {\r\n      worker.restart();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message to workers\r\n   */\r\n  send(command: Command) {\r\n    const workers = this.getWorkerProcesses();\r\n\r\n    for (const worker of workers) {\r\n      if (\r\n        command.to === 'workers' ||\r\n        (worker.process !== undefined && worker.process.pid === command.to)\r\n      ) {\r\n        if (this.useLogging) {\r\n          console.info(`[PRIMARY -> PID ${worker.process.pid}]`, command);\r\n        }\r\n\r\n        worker.process.send(command);\r\n      }\r\n    }\r\n  }\r\n}\r\n","import type { KeyPair } from './index.d';\r\ntype Process = typeof cluster.worker;\r\n\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\nexport class Worker {\r\n  process: Process;\r\n\r\n  constructor(worker: Process, onMessage: (message: any) => Promise<void>) {\r\n    this.process = worker;\r\n\r\n    this.process.on('message', async (message) => {\r\n      if (this.process.process !== undefined) {\r\n        console.info(`[PRIMARY -> PID ${this.process.process.pid}]`, message);\r\n        await onMessage(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Restarts the worker\r\n   */\r\n  restart() {\r\n    this.primaryCommand('shutdown');\r\n\r\n    this.kill();\r\n  }\r\n\r\n  /**\r\n   * Kills the worker\r\n   */\r\n  kill() {\r\n    this.process.removeAllListeners();\r\n    this.process.kill('SIGKILL');\r\n    this.process = undefined;\r\n  }\r\n\r\n  /**\r\n   * Sends a message from the worker to the primary\r\n   */\r\n  send(command: Command) {\r\n    console.info(`[PID ${this.process.process.pid} -> PRIMARY]`, command);\r\n    this.process.process.send(command);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  workerCommand(command: string, args: KeyPair = {}) {\r\n    this.send(new Command(command, args, this.process.process.pid, 'workers'));\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  primaryCommand(command: string, args: KeyPair = {}) {\r\n    this.send(new Command(command, args, this.process.process.pid, 'primary'));\r\n  }\r\n}\r\n","import type { iQueue } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\ntype Priamry = typeof cluster;\r\ntype Worker = typeof cluster.worker;\r\n\r\nexport class Queue implements iQueue {\r\n  queue: Command[] = [];\r\n  primary: Priamry;\r\n\r\n  constructor(primary: Priamry) {\r\n    this.primary = primary;\r\n  }\r\n\r\n  /**\r\n   * Adds a command to the queue\r\n   */\r\n  add(command: Command) {\r\n    const index = this.queue.push(command);\r\n    this.primary.emit('newCommand', command.to);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Removes the first command from the queue\r\n   */\r\n  shift() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  /**\r\n   * Gets the first command in the queue and may send it to the worker to do\r\n   */\r\n  next(worker?: Worker): Command | undefined {\r\n    const command = this.queue.shift();\r\n\r\n    if (command === undefined) {\r\n      return;\r\n    }\r\n\r\n    const pid = cluster.isPrimary ? 'primary' : worker.process.pid;\r\n    const newCommand = command.clone('primary', pid);\r\n\r\n    if (worker) {\r\n      worker.send(newCommand);\r\n    }\r\n\r\n    return newCommand;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}