{"version":3,"sources":["../../src/index.ts","../../src/cli.ts","../../src/command.ts","../../src/commands.ts","../../src/primary.ts","../../src/queue.ts","../../src/primaryEvents.ts","../../src/workerEvents.ts","../../src/worker.ts"],"sourcesContent":["import type { CliDefinition, CommandAction } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Cli } from './cli';\r\nimport { Primary } from './primary';\r\nimport { defaultCommands } from './commands';\r\nimport { Command } from './command';\r\nimport { Worker } from './worker';\r\n\r\nconst noop = () => undefined;\r\n\r\nexport class Cluster {\r\n  cliCommands: CliDefinition[] = [];\r\n  useLogging: boolean;\r\n  onPrimaryCommand: CommandAction = noop;\r\n  onWorkerCommand: CommandAction = noop;\r\n\r\n  constructor(commands: CliDefinition[] = [], useLogging: boolean = false) {\r\n    this.useLogging = useLogging;\r\n\r\n    // Default actions\r\n    for (const defaultCommand of defaultCommands.concat(commands)) {\r\n      if (defaultCommand.command.indexOf('cli:') === 0) {\r\n        // Register CLI commands\r\n        this.cliCommands.push(defaultCommand);\r\n      } else {\r\n        // Register actions\r\n        Command.register(defaultCommand.command, defaultCommand.action);\r\n      }\r\n    }\r\n\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Cluster node command handlers\r\n   */\r\n  onCommand(onPrimaryCommand: CommandAction, onWorkerCommand: CommandAction) {\r\n    this.onPrimaryCommand = onPrimaryCommand;\r\n    this.onWorkerCommand = onWorkerCommand;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Start the cluster nodes\r\n   */\r\n  async start(\r\n    onPrimaryStart: (primary: Primary) => Promise<void> = noop,\r\n    onWorkerStart: (worker: Worker) => Promise<void> = noop,\r\n    cliActive: boolean = true,\r\n    maxCpus?: number\r\n  ) {\r\n    if (cluster.isPrimary) {\r\n      const cli = new Cli(this.cliCommands, cliActive);\r\n      const primary = new Primary(\r\n        cluster,\r\n        cli,\r\n        this.onPrimaryCommand,\r\n        this.useLogging\r\n      );\r\n\r\n      // Parse the CLI\r\n      cli.start();\r\n\r\n      // Wait for the primary queue to be empty\r\n      await primary.start(maxCpus);\r\n      await onPrimaryStart(primary);\r\n    } else {\r\n      await onWorkerStart(\r\n        new Worker(cluster.worker, this.onWorkerCommand, this.useLogging)\r\n      );\r\n    }\r\n  }\r\n}\r\n","import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command as Commander } from 'commander';\r\nimport { Command } from './command';\r\nimport { internalCommands } from './commands';\r\n\r\nconst { name, description, version } = require('../package.json');\r\n\r\nconst removeChars = /[^A-Za-z0-9_]/g;\r\n\r\nexport class Cli {\r\n  program: Commander;\r\n  active: boolean = true;\r\n\r\n  constructor(definitions: CliDefinition[], active: boolean = true) {\r\n    this.active = active;\r\n    if (this.active === false) {\r\n      return;\r\n    }\r\n\r\n    this.program = new Commander();\r\n    this.program.name(name).description(description).version(version);\r\n\r\n    for (const definition of definitions) {\r\n      this.register(definition);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Registers a new CLI command\r\n   */\r\n  register(definition: CliDefinition) {\r\n    if (this.active === false) {\r\n      return;\r\n    }\r\n\r\n    if (!cluster.isPrimary) {\r\n      return;\r\n    }\r\n\r\n    const commandName = definition.command.substring(4);\r\n\r\n    // Register the definition as a command\r\n    Command.register(definition.command, definition.action);\r\n\r\n    // Register the command\r\n    const newCommand =\r\n      commandName === '' ? this.program : this.program.command(commandName);\r\n\r\n    newCommand.description(definition.description);\r\n\r\n    // Define the end-of-line arguments\r\n    const argKeys = Object.keys(definition.args);\r\n\r\n    for (const arg of argKeys) {\r\n      const description = definition.args[arg];\r\n\r\n      newCommand.argument(arg, description);\r\n    }\r\n\r\n    // Define the flags/options\r\n    for (const option of Object.keys(definition.options)) {\r\n      const description = definition.options[option];\r\n\r\n      newCommand.option(option, description);\r\n    }\r\n\r\n    // program.action(definition.action);\r\n    newCommand.action((...args: string[] & [(KeyPair | string)?]) => {\r\n      const options =\r\n        typeof args[args.length - 2] === 'string'\r\n          ? {}\r\n          : (args[args.length - 2] as KeyPair);\r\n\r\n      options.cli = {};\r\n\r\n      let i = 0;\r\n      for (const key of argKeys) {\r\n        options.cli[key.replace(removeChars, '')] = args[i];\r\n        i += 1;\r\n      }\r\n\r\n      cluster.emit(\r\n        'message',\r\n        new Command(\r\n          definition.command,\r\n          options,\r\n          'cli',\r\n          internalCommands.enqueueJobPrimary\r\n        )\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Start the CLI\r\n   */\r\n  start() {\r\n    if (this.active === false) {\r\n      return;\r\n    }\r\n\r\n    this.program.parse(process.argv);\r\n  }\r\n}\r\n","import type {\r\n  CommandAction,\r\n  CommandFrom,\r\n  CommandTo,\r\n  iCommand,\r\n  KeyPair,\r\n  QuickSends,\r\n} from './index.d';\r\n\r\nconst commands: KeyPair<CommandAction> = {};\r\n\r\nexport class Command implements iCommand {\r\n  command: string;\r\n  args: KeyPair;\r\n  from: CommandFrom;\r\n  to: CommandTo;\r\n\r\n  /**\r\n   * Registers a new command\r\n   */\r\n  static register(command: string, onAction: CommandAction) {\r\n    commands[command] = onAction;\r\n  }\r\n\r\n  /**\r\n   * Generates a command from a JSON\r\n   */\r\n  static fromJSON(json: KeyPair) {\r\n    return new Command(json.command, json.args, json.from, json.to);\r\n  }\r\n\r\n  /**\r\n   * Constructor\r\n   */\r\n  constructor(\r\n    command: string,\r\n    args: KeyPair,\r\n    from: CommandFrom,\r\n    to: CommandTo\r\n  ) {\r\n    if (commands[command] === undefined && command[0] !== '_') {\r\n      throw new RangeError(`\"${command}\" has not been registered.`);\r\n    }\r\n\r\n    this.command = command;\r\n    this.args = args;\r\n    this.from = from;\r\n    this.to = to;\r\n  }\r\n\r\n  /**\r\n   * Clones a command and changes the to and from properties\r\n   */\r\n  clone(from: CommandFrom, to: CommandTo) {\r\n    return new Command(this.command, this.args, from, to);\r\n  }\r\n\r\n  /**\r\n   * Runs the command\r\n   */\r\n  async run(state: KeyPair, quickSends: QuickSends) {\r\n    return commands[this.command](this, state, quickSends);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  log(from?: string) {\r\n    console.log(\r\n      `[${from || this.from} -> ${this.to}] ${this.command}`,\r\n      this.args\r\n    );\r\n  }\r\n}\r\n","import type { CliDefinition, KeyPair, QuickSends } from './index.d';\r\n\r\nimport { Command } from './command';\r\n\r\nexport const internalCommands: {\r\n  getNextJob: '_getNextJob';\r\n  getNextPrimaryJob: '_getNextJob_primary';\r\n  enqueueJob: '_enqueueJob';\r\n  enqueueJobPrimary: '_enqueueJob_primary';\r\n  newJobNotice: '_newJobNotice';\r\n  message: 'message';\r\n} = {\r\n  getNextJob: '_getNextJob',\r\n  getNextPrimaryJob: '_getNextJob_primary',\r\n  enqueueJob: '_enqueueJob',\r\n  enqueueJobPrimary: '_enqueueJob_primary',\r\n  newJobNotice: '_newJobNotice',\r\n  message: 'message',\r\n};\r\n\r\n/**\r\n * Default commands\r\n */\r\nexport const defaultCommands: CliDefinition[] = [\r\n  {\r\n    command: 'log',\r\n    action: async (command: Command, state: KeyPair, sends: QuickSends) => {\r\n      command.log();\r\n      console.log('State:', state);\r\n    },\r\n  },\r\n  {\r\n    command: 'setState',\r\n    action: async (command: Command, state: KeyPair, sends: QuickSends) => {\r\n      for (const key of Object.keys(command.args)) {\r\n        state[key] = command.args[key];\r\n      }\r\n    },\r\n  },\r\n  {\r\n    command: 'iterateState',\r\n    action: async (command: Command, state: KeyPair, sends: QuickSends) => {\r\n      for (const key of Object.keys(command.args)) {\r\n        if (state[key] === undefined) {\r\n          state[key] = 0;\r\n        }\r\n\r\n        state[key] += command.args[key];\r\n      }\r\n    },\r\n  },\r\n];\r\n","import type { CommandAction, KeyPair, QuickSends } from './index.d';\r\n\r\nimport cluster from 'cluster';\r\nimport * as os from 'os';\r\nimport { Cli } from './cli';\r\nimport { Command } from './command';\r\nimport { Queue } from './queue';\r\nimport { internalCommands } from './commands';\r\nimport { getPrimaryEvents } from './primaryEvents';\r\n\r\ntype Process = typeof cluster;\r\ntype Worker = typeof cluster.worker;\r\n\r\nconst cpus = os.cpus();\r\nconst numWorkers = cpus.length;\r\n\r\nexport class Primary {\r\n  process: Process;\r\n  primaryQueue: Queue;\r\n  workerQueue: Queue;\r\n  useLogging: boolean;\r\n  cli: Cli;\r\n  state: KeyPair = {};\r\n  sends: QuickSends;\r\n  onMessage: CommandAction;\r\n\r\n  constructor(\r\n    process: Process,\r\n    cli: Cli,\r\n    onMessage: CommandAction,\r\n    useLogging: boolean = false\r\n  ) {\r\n    this.cli = cli;\r\n    this.process = process;\r\n    this.useLogging = useLogging;\r\n    this.primaryQueue = new Queue();\r\n    this.workerQueue = new Queue();\r\n    this.onMessage = onMessage;\r\n    this.sends = getPrimaryEvents(this);\r\n\r\n    /**\r\n     * Primary receives a general message from worker\r\n     */\r\n    process.on(\r\n      'message',\r\n      async (worker: Worker | Command, possibleCommand?: Command) => {\r\n        const hasWorker = possibleCommand !== undefined;\r\n        const command = Command.fromJSON(possibleCommand || worker);\r\n\r\n        if (this.useLogging) {\r\n          const from = hasWorker\r\n            ? (worker as Worker).process.pid\r\n            : (worker as Command).from;\r\n\r\n          command.log(from.toString());\r\n        }\r\n\r\n        switch (command.to) {\r\n          case internalCommands.enqueueJob:\r\n            await this.enqueueJob(command);\r\n            break;\r\n\r\n          case internalCommands.getNextJob:\r\n            await this.getNextJob(worker as Worker);\r\n            break;\r\n\r\n          case internalCommands.message:\r\n            await this.message(command);\r\n            break;\r\n\r\n          case internalCommands.enqueueJobPrimary:\r\n            await this.enqueueJob(command);\r\n            break;\r\n\r\n          case internalCommands.getNextPrimaryJob:\r\n            await this.getNextPrimaryJob();\r\n            break;\r\n\r\n          case internalCommands.newJobNotice:\r\n            break;\r\n\r\n          default:\r\n            console.warn('Unknown command:', command);\r\n            return;\r\n        }\r\n      }\r\n    );\r\n\r\n    /**\r\n     * When a worker quits\r\n     */\r\n    process.on('exit', (worker, code, signal) => {\r\n      if (this.useLogging) {\r\n        console.info(`${worker.process.pid} died: ${code} ${signal}`);\r\n      }\r\n\r\n      this.spawnWorker();\r\n    });\r\n\r\n    /**\r\n     * When a worker spawns\r\n     */\r\n    process.on('online', (worker) => {\r\n      if (this.useLogging) {\r\n        console.info('Worker ' + worker.process.pid + ' is online');\r\n      }\r\n\r\n      this.getNextJob(worker);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Starts the priamry process\r\n   */\r\n  async start(maxCpus: number = numWorkers) {\r\n    await Promise.all([\r\n      new Promise((resolve) => {\r\n        setTimeout(() => {\r\n          if (this.primaryQueue.queue.length === 0) {\r\n            resolve(true);\r\n          }\r\n        }, 100);\r\n      }),\r\n    ]);\r\n\r\n    if (this.useLogging) {\r\n      console.info('Primary cluster setting up ' + maxCpus + ' workers...');\r\n    }\r\n\r\n    for (var i = 0; i < maxCpus; i++) {\r\n      this.spawnWorker();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn a new worker that self-cleans up\r\n   */\r\n  spawnWorker() {\r\n    let worker = this.process.fork();\r\n\r\n    worker.on('disconnect', () => {\r\n      worker.removeAllListeners();\r\n      worker.kill();\r\n      worker = undefined;\r\n    });\r\n\r\n    return worker;\r\n  }\r\n\r\n  /**\r\n   * Adds a command for later processing\r\n   */\r\n  addTask(command: Command): Command {\r\n    if (command.to === 'primary') {\r\n      this.primaryQueue.add(command);\r\n    } else {\r\n      this.workerQueue.add(command);\r\n    }\r\n\r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * Get worker processes\r\n   */\r\n  getWorkers() {\r\n    return Object.values(cluster.workers);\r\n  }\r\n\r\n  /**\r\n   * Enqueues a command.  If from primary, it will run the command instead\r\n   */\r\n  private async enqueueJob(command: Command) {\r\n    if (command.to === internalCommands.enqueueJobPrimary) {\r\n      // Primary should run its next command\r\n      const newCommand = await this.onMessage(command, this.state, this.sends);\r\n\r\n      if (newCommand === undefined) {\r\n        await command.run(this.state, this.sends);\r\n      } else {\r\n        await (newCommand as Command).run(this.state, this.sends);\r\n      }\r\n    } else {\r\n      // All workers should be told a new command has appeared\r\n      this.addTask(command);\r\n\r\n      if (this.process.workers) this.sends.newJobNotice();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the next job from the queue and sends it to a worker\r\n   */\r\n  private async getNextJob(worker: Worker) {\r\n    const nextCommand = this.workerQueue.getNext(worker.process.pid);\r\n\r\n    if (nextCommand === undefined) {\r\n      return;\r\n    }\r\n\r\n    const finalCommand = await this.onMessage(\r\n      nextCommand,\r\n      this.state,\r\n      this.sends\r\n    );\r\n\r\n    if (finalCommand) {\r\n      worker.send(finalCommand);\r\n    } else {\r\n      worker.send(nextCommand);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Gets the next priamry job and runs it\r\n   */\r\n  private async getNextPrimaryJob() {\r\n    const nextCommand = this.primaryQueue.getNext('primary');\r\n\r\n    if (nextCommand === undefined) {\r\n      return;\r\n    }\r\n\r\n    // @TODO might be bad\r\n    const finalCommand = await this.onMessage(\r\n      nextCommand,\r\n      this.state,\r\n      this.sends\r\n    );\r\n\r\n    if (finalCommand === undefined) {\r\n      await nextCommand.run(this.state, this.sends);\r\n    } else {\r\n      await (finalCommand as Command).run(this.state, this.sends);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generic message handler\r\n   */\r\n  private async message(command: Command) {\r\n    if (this.useLogging) {\r\n      console.log('Primary Message:', command);\r\n    }\r\n\r\n    await this.onMessage(command, this.state, this.sends);\r\n  }\r\n}\r\n","import type { CommandTo, iQueue } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\nexport class Queue implements iQueue {\r\n  queue: Command[] = [];\r\n\r\n  /**\r\n   * Adds a command to the queue\r\n   */\r\n  add(command: Command) {\r\n    const index = this.queue.push(command);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Removes the first command from the queue\r\n   */\r\n  shift() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  /**\r\n   * Gets the first command in the queue and may send it to the worker to do\r\n   */\r\n  getNext(to: CommandTo): Command | undefined {\r\n    const command = this.queue.shift();\r\n\r\n    if (command === undefined) {\r\n      return;\r\n    }\r\n\r\n    const newCommand = command.clone('primary', to);\r\n\r\n    return newCommand;\r\n  }\r\n}\r\n","import type { CommandTo, KeyPair } from './index.d';\r\n\r\nimport { Command } from './command';\r\nimport { internalCommands } from './commands';\r\nimport { Primary } from './primary';\r\n\r\nexport function getPrimaryEvents(primary: Primary) {\r\n  return {\r\n    /**\r\n     * @TODO\r\n     */\r\n    getNextJob: () => {\r\n      return primary.process.emit(\r\n        'message',\r\n        new Command(\r\n          internalCommands.getNextPrimaryJob,\r\n          {},\r\n          'primary',\r\n          internalCommands.getNextPrimaryJob\r\n        )\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    enqueueJob: (\r\n      command: string,\r\n      args: KeyPair = {},\r\n      to: CommandTo = 'workers'\r\n    ) => {\r\n      if (to === 'primary') {\r\n        return primary.process.emit(\r\n          'message',\r\n          new Command(\r\n            command,\r\n            args,\r\n            'primary',\r\n            internalCommands.enqueueJobPrimary\r\n          )\r\n        );\r\n      } else {\r\n        return primary.process.emit(\r\n          'message',\r\n          new Command(command, args, 'primary', internalCommands.enqueueJob)\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    newJobNotice: () => {\r\n      return primary.process.emit(\r\n        'message',\r\n        new Command(\r\n          internalCommands.newJobNotice,\r\n          {},\r\n          'primary',\r\n          internalCommands.newJobNotice\r\n        )\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    message: async (command: string, args: KeyPair = {}) => {\r\n      return primary.process.emit(\r\n        'message',\r\n        new Command(command, args, 'primary', internalCommands.message)\r\n      );\r\n    },\r\n  };\r\n}\r\n","import type { CommandTo, KeyPair } from './index.d';\r\n\r\nimport { Command } from './command';\r\nimport { internalCommands } from './commands';\r\nimport { Worker } from './worker';\r\n\r\nexport function getWorkerEvents(worker: Worker) {\r\n  return {\r\n    /**\r\n     * @TODO\r\n     */\r\n    getNextJob: () => {\r\n      return worker.process.send(\r\n        new Command(\r\n          internalCommands.getNextJob,\r\n          {},\r\n          worker.pid,\r\n          internalCommands.getNextJob\r\n        )\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    enqueueJob: (\r\n      command: string,\r\n      args: KeyPair = {},\r\n      to: CommandTo = 'workers'\r\n    ) => {\r\n      if (to === 'primary') {\r\n        return worker.process.send(\r\n          new Command(\r\n            command,\r\n            args,\r\n            worker.pid,\r\n            internalCommands.enqueueJobPrimary\r\n          )\r\n        );\r\n      } else {\r\n        return worker.process.send(\r\n          new Command(command, args, worker.pid, internalCommands.enqueueJob)\r\n        );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    newJobNotice: () => {\r\n      return worker.process.send(\r\n        new Command(\r\n          internalCommands.newJobNotice,\r\n          {},\r\n          worker.pid,\r\n          internalCommands.newJobNotice\r\n        )\r\n      );\r\n    },\r\n\r\n    /**\r\n     * @TODO\r\n     */\r\n    message: async (command: string, args: KeyPair = {}) => {\r\n      return worker.process.send(\r\n        new Command(command, args, worker.pid, internalCommands.message)\r\n      );\r\n    },\r\n  };\r\n}\r\n","import type { CommandAction, KeyPair, QuickSends } from './index.d';\r\ntype Process = typeof cluster.worker;\r\n\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\nimport { internalCommands } from './commands';\r\nimport { getWorkerEvents } from './workerEvents';\r\n\r\nexport class Worker {\r\n  process: Process;\r\n  useLogging: boolean;\r\n  state: KeyPair = {};\r\n  sends: QuickSends;\r\n  pid: number;\r\n  isWorking: boolean = false;\r\n\r\n  constructor(\r\n    process: Process,\r\n    onCommand: CommandAction,\r\n    useLogging: boolean = false\r\n  ) {\r\n    this.process = process;\r\n    this.useLogging = useLogging;\r\n    this.pid = this.process.process.pid;\r\n    this.sends = getWorkerEvents(this);\r\n\r\n    /**\r\n     * Primary receives a general message from worker\r\n     */\r\n    process.on(internalCommands.message, async (json: KeyPair) => {\r\n      if (this.isWorking) {\r\n        return;\r\n      }\r\n\r\n      this.isWorking = true;\r\n      const command = Command.fromJSON(json);\r\n\r\n      if (this.useLogging) {\r\n        command.log('primary');\r\n      }\r\n\r\n      switch (command.to) {\r\n        case internalCommands.newJobNotice:\r\n          this.sends.getNextJob();\r\n          break;\r\n\r\n        case internalCommands.message:\r\n          break;\r\n      }\r\n\r\n      const newCommand = await onCommand(command, this.state, this.sends);\r\n\r\n      if (newCommand === undefined) {\r\n        await command.run(this.state, this.sends);\r\n      } else {\r\n        await (newCommand as Command).run(this.state, this.sends);\r\n      }\r\n      this.isWorking = false;\r\n\r\n      this.sends.getNextJob();\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Kills the worker\r\n   */\r\n  kill() {\r\n    this.process.removeAllListeners();\r\n    this.process.kill('SIGKILL');\r\n    this.process = undefined;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}