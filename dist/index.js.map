{"version":3,"sources":["../src/index.ts","../src/cli.ts","../src/command.ts","../src/master.ts","../src/worker.ts","../src/queue.ts"],"sourcesContent":["import type { CliDefinition } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Cli } from './cli';\r\nimport { Command } from './command';\r\nimport { Master } from './master';\r\nimport { Queue } from './queue';\r\n\r\nexport function startCluster(\r\n  commands: CliDefinition[],\r\n  onMasterStart: (master: Master) => void,\r\n  onMasterMessage: (worker: typeof cluster.worker, message: any) => void,\r\n  onWorkerStart: (worker: typeof cluster.worker) => void,\r\n  onWorkerMessage: (message: any) => void,\r\n  useLogging: boolean = false\r\n) {\r\n  if (cluster.isPrimary) {\r\n    const primaryQueue = new Queue(cluster);\r\n    const workerQueue = new Queue(cluster);\r\n    const cli = new Cli(primaryQueue, commands);\r\n    const master = new Master(\r\n      cluster,\r\n      cli,\r\n      primaryQueue,\r\n      workerQueue,\r\n      onMasterMessage,\r\n      onWorkerMessage,\r\n      useLogging\r\n    );\r\n    onMasterStart(master);\r\n  } else {\r\n    const worker = cluster.worker;\r\n    onWorkerStart(worker);\r\n  }\r\n}\r\n\r\n// @TODO: build a test bench\r\n\r\nstartCluster(\r\n  [\r\n    {\r\n      command: 'cli:test',\r\n      description: 'Test',\r\n      args: {},\r\n      options: {},\r\n      action: (command: Command) => {},\r\n    },\r\n    {\r\n      command: 'doThing',\r\n      action: (command: Command) => {},\r\n    },\r\n  ],\r\n  () => {},\r\n  () => {},\r\n  () => {},\r\n  () => {},\r\n  true\r\n);\r\n","import type { CliDefinition, KeyPair } from './index.d';\r\nimport cluster from 'cluster';\r\nimport { Command as Commander } from 'commander';\r\nimport { Queue } from './queue';\r\nimport { Command } from './command';\r\n\r\nconst { name, description, version } = require('../package.json');\r\n\r\nexport class Cli {\r\n  queue: Queue;\r\n  program: Commander;\r\n\r\n  constructor(queue: Queue, definitions: CliDefinition[]) {\r\n    this.queue = queue;\r\n    this.program = new Commander();\r\n    this.program.name(name).description(description).version(version);\r\n\r\n    for (const definition of definitions) {\r\n      this.register(definition);\r\n    }\r\n  }\r\n\r\n  register(definition: CliDefinition) {\r\n    if (!cluster.isPrimary) {\r\n      return;\r\n    }\r\n\r\n    const isCliCommand = definition.command.indexOf('cli:') === 0;\r\n\r\n    const commandName = isCliCommand\r\n      ? definition.command.substring(3)\r\n      : definition.command;\r\n\r\n    // Register the definition as a command\r\n    Command.register(commandName, definition.action);\r\n\r\n    if (!isCliCommand) {\r\n      return;\r\n    }\r\n\r\n    // Register the command\r\n    const newCommand = this.program\r\n      .command(commandName)\r\n      .description(definition.description);\r\n\r\n    // Define the end-of-line arguments\r\n    const argKeys = Object.keys(definition.args);\r\n\r\n    for (const arg of argKeys) {\r\n      const description = definition.args[arg];\r\n\r\n      newCommand.argument(arg, description);\r\n    }\r\n\r\n    // Define the flags/options\r\n    for (const option of Object.keys(definition.options)) {\r\n      const description = definition.options[option];\r\n\r\n      newCommand.option(option, description);\r\n    }\r\n\r\n    // program.action(definition.action);\r\n    newCommand.action((...args: string[] & [(KeyPair | string)?]) => {\r\n      const options =\r\n        typeof args[args.length - 1] === 'string'\r\n          ? {}\r\n          : (args[args.length - 1] as KeyPair);\r\n\r\n      options.cli = {};\r\n\r\n      let i = 0;\r\n      for (const key of argKeys) {\r\n        options.cli[key] = args[i];\r\n        i += 1;\r\n      }\r\n\r\n      this.queue.add(\r\n        new Command(definition.command, options, 'cli', 'primary')\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  start() {\r\n    this.program.parse(process.argv);\r\n  }\r\n}\r\n","import type { CommandAction, iCommand, KeyPair } from './index.d';\r\n\r\nconst commands: KeyPair<CommandAction> = {};\r\n\r\nexport class Command implements iCommand {\r\n  command: string;\r\n  args: KeyPair;\r\n  from: number | 'primary' | 'cli';\r\n  to: number | 'workers' | 'primary';\r\n\r\n  /**\r\n   *\r\n   */\r\n  static register(command: string, onAction: CommandAction) {\r\n    commands[command] = onAction;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(\r\n    command: string,\r\n    args: KeyPair,\r\n    from: number | 'primary' | 'cli',\r\n    to: number | 'workers' | 'primary'\r\n  ) {\r\n    if (commands[command] === undefined) {\r\n      throw new RangeError(`\"${command}\" has not been regsitered.`);\r\n    }\r\n    this.command = command;\r\n    this.args = args;\r\n    this.from = from;\r\n    this.to = to;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  clone(from: number | 'primary', to: number | 'workers' | 'primary') {\r\n    return new Command(this.command, this.args, from, to);\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  run() {\r\n    return commands[this.command](this.args);\r\n  }\r\n}\r\n","type Process = typeof cluster;\r\n\r\nimport cluster from 'cluster';\r\nimport * as os from 'os';\r\nimport { Cli } from './cli';\r\nimport { Command } from './command';\r\nimport { Queue } from './queue';\r\nimport { Worker } from './worker';\r\n\r\nconst cpus = os.cpus();\r\nconst numWorkers = cpus.length;\r\n\r\nexport class Master {\r\n  process: Process;\r\n  workers: Worker[] = [];\r\n  priamryQueue: Queue;\r\n  workerQueue: Queue;\r\n  useLogging: boolean;\r\n  cli: Cli;\r\n\r\n  constructor(\r\n    process: Process,\r\n    cli: Cli,\r\n    priamryQueue: Queue,\r\n    workerQueue: Queue,\r\n    onMessage: (worker: typeof cluster.worker, command: Command) => void,\r\n    onWorkerMessage: (message: any) => void,\r\n    useLogging: boolean = false\r\n  ) {\r\n    this.cli = cli;\r\n    this.process = process;\r\n    this.useLogging = useLogging;\r\n    this.priamryQueue = priamryQueue;\r\n    this.workerQueue = workerQueue;\r\n\r\n    process.on('newCommand', (to: string) => {\r\n      // New command enqueued\r\n      if (to === 'primary') {\r\n        const command = this.workerQueue.next();\r\n        command.run();\r\n      }\r\n    });\r\n\r\n    process.on('message', (worker, command) => {\r\n      // Primary receives message from worker\r\n      if (command.command === '_next') {\r\n        const nextCommand = this.workerQueue.next(worker);\r\n        onMessage(worker, nextCommand);\r\n      } else {\r\n        onMessage(worker, command);\r\n      }\r\n    });\r\n\r\n    process.on('exit', (worker, code, signal) => {\r\n      // When a worker quits\r\n      if (this.useLogging) {\r\n        console.info(\r\n          'Worker ' +\r\n            worker.process.pid +\r\n            ' died with code: ' +\r\n            code +\r\n            ', and signal: ' +\r\n            signal\r\n        );\r\n      }\r\n\r\n      this.spawnWorker();\r\n    });\r\n\r\n    process.on('online', (worker) => {\r\n      // When a worker spawns\r\n      if (this.useLogging) {\r\n        console.info('Worker ' + worker.process.pid + ' is online');\r\n      }\r\n\r\n      const newWorker = new Worker(worker, onWorkerMessage);\r\n      this.workers.push(newWorker);\r\n    });\r\n\r\n    if (this.useLogging) {\r\n      console.info('Master cluster setting up ' + numWorkers + ' workers...');\r\n    }\r\n\r\n    for (var i = 0; i < numWorkers; i++) {\r\n      this.spawnWorker();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Spawn a new worker that self-cleans up\r\n   */\r\n  spawnWorker() {\r\n    let worker = this.process.fork();\r\n\r\n    worker.on('disconnect', () => {\r\n      worker.removeAllListeners();\r\n      worker.kill();\r\n      worker = undefined;\r\n    });\r\n\r\n    return worker;\r\n  }\r\n\r\n  /**\r\n   * Adds a command for later processing\r\n   */\r\n  async addTask(command: Command): Promise<Command> {\r\n    if (command.to === 'primary') {\r\n      this.priamryQueue.add(command);\r\n    } else {\r\n      this.workerQueue.add(command);\r\n    }\r\n\r\n    return command;\r\n  }\r\n\r\n  /**\r\n   * Get worker processes\r\n   */\r\n  getWorkerProcesses() {\r\n    return Object.values(cluster.workers);\r\n  }\r\n\r\n  /**\r\n   * Restart all Worker instances\r\n   */\r\n  restartWorkers() {\r\n    for (const worker of this.workers) {\r\n      worker.restart();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message to workers\r\n   */\r\n  send(command: Command) {\r\n    const workers = this.getWorkerProcesses();\r\n\r\n    for (const worker of workers) {\r\n      if (\r\n        command.to === 'workers' ||\r\n        (worker.process !== undefined && worker.process.pid === command.to)\r\n      ) {\r\n        if (this.useLogging) {\r\n          console.info(`[MASTER -> PID ${worker.process.pid}]`, command);\r\n        }\r\n\r\n        worker.process.send(command);\r\n      }\r\n    }\r\n  }\r\n}\r\n","type Process = typeof cluster.worker;\r\n\r\nimport cluster from 'cluster';\r\n\r\nexport class Worker {\r\n  process: Process;\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(worker: Process, onMessage: (message: any) => void) {\r\n    this.process = worker;\r\n\r\n    this.process.on('message', (message) => {\r\n      if (this.process.process !== undefined) {\r\n        console.info(`[MASTER -> PID ${this.process.process.pid}]`, message);\r\n        onMessage(message);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  restart() {\r\n    this.send({\r\n      command: 'shutdown',\r\n      from: this.process.process.pid,\r\n    });\r\n\r\n    this.kill();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  kill() {\r\n    this.process.removeAllListeners();\r\n    this.process.kill('SIGKILL');\r\n    this.process = undefined;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  send(message) {\r\n    console.info(`[PID ${this.process.process.pid} -> MASTER]`, message);\r\n    this.process.process.send(message);\r\n  }\r\n}\r\n","type Priamry = typeof cluster;\r\ntype Worker = typeof cluster.worker;\r\n\r\nimport cluster from 'cluster';\r\nimport { Command } from './command';\r\n\r\nexport class Queue {\r\n  queue: Command[] = [];\r\n  primary: Priamry;\r\n\r\n  /**\r\n   *\r\n   */\r\n  constructor(primary: Priamry) {\r\n    this.primary = primary;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  add(command: Command) {\r\n    const index = this.queue.push(command);\r\n    this.primary.emit('newCommand', command.to);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  shift() {\r\n    return this.queue.shift();\r\n  }\r\n\r\n  /**\r\n   *\r\n   */\r\n  next(worker?: Worker): Command | undefined {\r\n    const command = this.queue.shift();\r\n\r\n    if (command === undefined) {\r\n      return;\r\n    }\r\n\r\n    const newCommand = command.clone('primary', worker.process.pid);\r\n\r\n    if (worker) {\r\n      worker.send(newCommand);\r\n    }\r\n\r\n    return newCommand;\r\n  }\r\n}\r\n"],"mappings":"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","names":[]}